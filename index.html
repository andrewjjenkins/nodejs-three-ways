<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Node.js Three Ways</title>

    <meta name="description" content="An OSCON 20214 Workshop. Learn to create Node.js applications using three approaches: vanilla Node.js for network services, Express MVC applications, and Reactive applications using Meteor">
		<meta name="author" content="Constantine Aaron Cois and Tim Palko">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>
    <!-- Wrap the entire slide show in a div using the "reveal" class. -->
    <div class="reveal">
        <!-- Wrap all slides in a single "slides" class -->
        <div class="slides">

            <!-- Introduction -->
            <section>
                <h2>Example two-column slide</h2>
                <div class="column" style="float: left;margin: 0;width: 50%;">
                    Content in here
                    <pre><code class="javascript">
fs = require('fs');
 
fs.readFile('f1.txt','utf8',

function(err,data) {
    if (err) {
    // handle error
       }
       console.log(data);
}

);
                    </code></pre>
                </div>
                <div class="column" style="float: left;margin: 0;width: 50%;">
                    More content
                    <pre><code class="javascript">
fs = require('fs');
 
fs.readFile('f1.txt','utf8',

function(err,data) {
    if (err) {
    // handle error
       }
       console.log(data);
}

);
                    </code></pre>
                </div>
            </section>

            <section>
                <h2>Before we get started, Install These:</h2>
                <br>
                <div class="column" style="float: left;margin: 0;width: 29%;">
                    <h4>OSX</h4>
                    <pre><code class="javascript">
(if you have homebrew)

$ brew install node
$ brew install redis
$ brew install mongo
                    </code></pre>

                </div>
                <div class="column" style="float: left;margin: 0;width: 40%;">
                    <h4>Ubuntu/Debian</h4>
                    <pre><code class="javascript">
(use sudo if necessary)

$ apt-get install nodejs
$ apt-get install redis-server
$ apt-get install mongodb
$ apt-get install npm


                    </code></pre>
                </div>
                <div class="column" style="float: left;margin: 0;width: 31%;">
                    <h4>Windows</h4>
                    <pre><code class="javascript">
(using chocolatey)

> cinst nodejs.install
> cinst redis
> cinst mongodb
                    </code></pre>
                </div>

<br><br><p>or go to:</p>
<a href="http://www.nodejs.org">http://www.nodejs.org</a> |
<a href="http://www.mongodb.org/downloads">http://www.mongodb.org/downloads</a> |
<a href="http://redis.io/download">http://redis.io/download</a>
<br>
<br><p>And clone the workshop repo:</p>
<pre><code class="javascript">
        $ git clone https://github.com/cacois/nodejs-three-ways

</code></pre>
            </section>

            <section>
                <h1>Node.js Three Ways</h1>
                <h2>A Tutorial in Three Acts</h2>
                <p>Constantine Aaron Cois and Tim Palko</p>
                <p>Carnegie Mellon University, Software Engineering Institute</p>
            </section>

            <section>
                <h2>Aaron = </h2>
                <p style="text-align: left;margin-left: 300;">{</p>
                <p style="text-align: left;margin-left: 350;">twitter: <a href="https://twitter.com/aaroncois">@aaroncois</a>,</p>
                <p style="text-align: left;margin-left: 350;">blog: <a href="http://www.codehenge.net">www.codehenge.net</a>,</p>
                <p style="text-align: left;margin-left: 350;">github: <a href="http://github.com/cacois">http://github.com/cacois </a></p>
                <p style="text-align: left;margin-left: 300;">}</p>
                <br>
                <h2>Tim =</h2>
                <p style="text-align: left;margin-left: 300;">{</p>
                <p style="text-align: left;margin-left: 300;">}</p>
            </section>
            <section>
                <h2>Code</h2>
                <b>Code</b> for this workshop can be found on github:
                <br><br>
                <h3><a href="https://github.com/cacois/nodejs-three-ways">https://github.com/cacois/nodejs-three-ways</a></h3>
                <br><br>
                <h2>Slides</h2>
                You can also find slides here:
                <br><br>
                <h3><a href="http://cacois.github.io/nodejs-three-ways/#/">http://cacois.github.io/nodejs-three-ways/#/</a></h3>
            </section>

            <section>
                <h1>The Basics</h1>
            </section>
            <section id="slide2">
                <h1>Node.js!</h1>
                <p>What's the big deal?</p>
            </section>

            <section>
                <h2>Cool things that Node is</h2>
                    <ul>
                      <li> JavaScript</li>
                      <li> Server-side</li>
                      <li> Event-driven</li>
                      <li> <em>Fast</em> and <em>Efficient</em></li>
                    </ul>
            </section>

            <section>
              <h2>JavaScript</h2>
              <br>
              <h3>This means you can...</h3>
              <br>
              <img src="./images/write_all_the_code_in_javascript1.jpg"></img>
            </section>

            <section>
              <h1>Advantages to JS</h1>
              <br><ul>
                  <li>Familiar</li>
                  <li>Low barrier to entry</li>
                  <li>Team Redundancy</li>
              </ul><br>
             <p>(Front-end devs and back-end devs speak the same language)</p>
            </section>

            <section>
              <h2>Let's talk <em>speed</em></h2>
              <br>
              <h3>Node.js was designed for highly-concurrent network applications</h3>
              <h4>(Read: scalable web apps, among other things)</h4>
            </section>

            <section data-background="./images/v8-logo.png"  data-background-size="80%">
              <h1 style="color:black">Fast</h1>
              <br>
              <br>
              <h3 style="color:black">Node uses the V8 JavaScript engine powering Google Chrome</h3><br>
              <h3 style="color:black">This means lightning fast JavaScript execution</h3>
            </section>

            <section>
              <h1>Efficient</h1>
              <h2>Node.js is <em>asynchronous</em> and <em>event-driven</em></h2>
              <br>
              <p>This means you have to think a bit differently</p>
            </section>

            <section data-background="./images/event-loop-1.png" data-background-size="70%"/>
            </section>

            <section data-background="./images/event-loop-2.png"  data-background-size="70%"/>
            </section>

            <section data-background="./images/event-loop-3.png"  data-background-size="70%"/>
            </section>

            <section>
              <h1>Callbacks</h1>
              <pre><code class="javascript">
                fs = require('fs');
 
                fs.readFile('f1.txt','utf8',function(err,data){
                  if (err) {
                    // handle error
                  }
                  console.log(data);
                });
              </code></pre>
            </section>

            <section>
              <h1>Callbacks</h1>
              <h3>Equivalent Syntax </h3>
              <pre><code class="javascript">
                fs = require('fs');
 
                fs.readFile('f1.txt','utf8',

                  function(err,data) {
                    if (err) {
                      // handle error
                    }
                    console.log(data);
                  }

                );
              </code></pre>
            </section>

            <section>
              <h2>Let's get to work</h2>
            </section>

            <!-- Act 1: Node.js Network Services -->
            <section>
                <h1>Act 1</h1>
                <h2>Node.js Network Services</h2>
            </section>

            <section>
                <h2>We're going to build a scalable, real-time notification service</h2>
            </section>

            <section>
              <h2>Here's what it will look like</h2>
              <img class="stretch" src="./images/notification-system.png" />
            </section>

            <section>
                <h2>Create a project directory and file</h2>
                <pre><code class="bash">
                  $ mkdir node-act1
                  $ cd node-act1
                  $ touch worker.js
                </code></pre>

                worker.js will be our asynchronous notification worker
            </section>

            <section>
                <h1>Part 1</h1>
            </section>

            <section>
                <h2>A first test</h2>

                Put the following in worker.js:
                <pre><code class="javascript">
                  console.log("Hello OSCON!");
                </code></pre>

                ...and run it:
                <pre><code class="bash">
                  $ node worker.js
                </code></pre>
            </section>

            <section>
              <h2>Node Package Manager (NPM)</h2>
              <br>
              We will need to use some external packages for our app.
              <br><br>
              Specifically, we will need the Redis client package. Install it using:
              <pre><code class="bash">
                $ npm install redis
              </code></pre>
              The package will be installed in a local node_modules directory. Check it out:
              <pre><code class="bash">
                $ ls node_modules
              </code></pre>
            </section>

            <section>
                Now we can start by connecting to Redis to receive Pub/Sub messages
                <br><br>
                Add the following to worker.js:
                <pre><code class="javascript">
              // import the redis module
              var redis = require("redis");

              // create a redis client object
              var pubSubClient = redis.createClient('6379', 'localhost');

              // subscribe to 'notifications' collection
              pubSubClient.subscribe("notifications");

              // define message handler
              pubSubClient.on("message", function(channel, message) {
                  console.log('Received a message: ' + message);
              });
                </code></pre>
              </section>
              <section>
                Start the redis server in one window...
                <pre><code class="bash">
                  $ redis-server
                </code></pre>
                ...and run your app in another...
                <pre><code class="bash">
                  $ node worker.js
                </code></pre>
            </section>

            <section>
                Now let's test. Write to the collecion in Redis:
                <pre><code class="bash">
  $ redis-cli

  redis-cli> publish notifications '{"identifier": 1, "message": "Huzzah!"}'
                </code></pre>
            </section>

            <section>
                Received a message: Huzzah!
                <br>
               <img src=./images/futurama-huzzah.jpg />
            </section>

            <section>
                <h1>Part 2</h1>
<br>
    If your code has errors, start with the files from directory
    <b><p> /act-1-network-services/begin-part-2/ </p></b>
            </section>

            <section>
              Now let's take a step back and set up some basic stuff for our project
            </section>

            <section>
                <h2>Config File</h2>
                <br>
                I like to use a module for config data
                <br><br>
                Create a file named config.js:
                <pre><code class="bash">
                  $ touch config.js
                </code></pre>
                .. and put the following content in it:
                <pre><code class="bash">
                module.exports = {
                  host: 'localhost',
                  port: 6379
                }
                </code></pre>
                The 'module.exports' value indicates what will be returned from a require(...) call to this file
            </section>

            <section>
              Now import the file into your worker.js app by adding the following to the top of the file:
              <pre><code class="javascript">
            var config = require("./config.js");
              </code></pre>
              Now we can replace the Redis client instantiation:
              <pre><code class="javascript">
            var pubSubClient = redis.createClient('6379', 'localhost');
              </code></pre>
              with:
              <pre><code class="javascript">
            var pubSubClient = redis.createClient(config.port, config.host);
              </code></pre>
              <br>
              Nifty!
            </section>

            <section>
              <h2>Package Management</h2>
              We've already seen how to install individual packages using NPM
              <br><br>
              But can we automate this, and centrally manage package requirements?
              <br><br>
              Yes, with a package.json file:
              <pre><code class="bash">
            $ touch package.json
              </code></pre>
            </section>

            <section>
              <h2>Package.json</h2>
              A lot of info can go into a package.json file
              <br><br>
              We'll only use a small bit of its functionality here. Write this:
              <pre><code class="json">
            {
              "name": "act-1-network-services",
              "author": "MY NAME &lt;my@email.com&gt;",
              "version": "1.0.0",
              "dependencies": {
                "redis": "*",
                "nodemailer": "*"
              },
              "engine": { "node" : ">=0.10.0" }
            }
              </code></pre>
              <p>This specifies:</p>
              <ul>
                <li>some metadata about the app</li>
                <li>a list of package dependencies (we'll need nodemailer later)</li>
                <li>a required Node version</li>
              </ul>

            </section>
            <section>
              <h2>NPM Install</h2>
              Now that we have a package.json, we can install the app and its dependencies in one command:
              <pre><code class="bash">
            $ npm install
              </code></pre>
              <p>NPM will look for a local package.json and use it to set everything up</p>
            </section>

            <section>
                <h1>Part 3</h1>
<br>
    If your code has errors, start with the files from directory
    <b><p> /act-1-network-services/begin-part-3/ </p></b>
            </section>

            <section>
                <h3>worker.js should look like this:</h2>
                <pre class="stretch"><code class="javascript" style="font-size: 13pt">
      // import the redis module
      var redis = require("redis");

      // read in the config file as a JavaScript object
      var config = require("./config.js");

      // create a redis client object
      var pubSubClient = redis.createClient(config.port, config.host);

      // subscribe to 'notifications' collection
      pubSubClient.subscribe("notifications");

      // define message handler
      pubSubClient.on("message", function(channel, message) {
          console.log('Received a message: ' + message);
      });
                </code></pre>
            </section>

            <section>
                Let's make that message handler function a bit more manageable
                <br><br>
                Move the closure out to a separtely defined function:
                <pre><code class="javascript">
            // define message handler
            pubSubClient.on("message", handleMessage);

            function handleMessage(channel, message) {
                console.log('Received a message: ' + message);
            }
                </code></pre>
            </section>

            <section>
                Now let's make it do something more interesting.
                <br><br>
                We want multiple, fault-tolerant workers to handle notifications. This will make our system scalable.
                <br><br>
                We can accomplish this by making all workers race to handle any notification dispatched - which means <em>locks</em>
            </section>
            <section>
                <h3>worker.js</h3>
                <pre><code class="javascript">
            ...
            // define message handler
            pubSubClient.on("message", handleMessage);

            function handleMessage(channel, message) {
                console.log('Received a message: ' + message);

                var payload = JSON.parse(message);

                acquireLock(payload, lockCallback);
            }
                </code></pre>

            Notice that we've identified two functions we need to write: <b>acquireLock</b> and the callback <b>lockCallback</b>
            </section>

            <section>
                <h2>acquireLock</h2>
                We can use Redis for locks, too. The first worker to write a lock for a given notification wins!
            </section>
            <section>
                <h3>worker.js</h3>
                <pre class="stretch"><code class="javascript">
...
var client = redis.createClient(config.port, config.host);
...
function acquireLock(payload, callback) {
    // create a lock id string
    var lockIdentifier = "lock." + payload.identifier;
    console.log("Trying to obtain lock: %s", lockIdentifier);

    client.setnx(lockIdentifier, "Worker Name", function(error, success) {
        if (error) {
            logger.error("Error acquiring lock for: %s", lockIdentifier);
            return callback(error, dataForCallback(false));
        }

        var data = {
            "acquired" : success,
            "lockIdentifier" : lockIdentifier,
            "payload" : payload };
        return callback(data);
    });
}
                </code></pre>

            </section>

            <section>
            <h2>You Are Special</h2>
                Give your worker a better name than "Worker Name"! Unique and memorable.
                <br><br>
                That way, if your worker acquires a lock on a central server, the lock can identify your worker.
                <br><br>(Protip: If you want to pass a worker name/id in from the command line, check out the <b>process.argv</b> object)
            </section>

            <section>
                <h2>lockCallback</h2>
                Now the callback after a worker tried to acquire a lock.
                <br><br>
                <h3>worker.js</h3>
                <pre><code class="javascript">
...
function lockCallback(data) {
    if(data.acquired == true) {
        console.log("I got the lock!");

        // send notification!
        // TODO: actually notify
        console.log('I win! Sending notification: %s',
                     JSON.stringify(data));
    }
    else console.log("No lock for me :(");
}
                </code></pre>
            </section>

            <section>
                We've written a lot of code - let's test
                <br><br>
                <pre class="stretch"><code class="bash">
    $ node worker.js
    (in another terminal)
    $ redis-cli

    redis-cli> publish notifications '{"identifier": 2, "message": "in a bottle"}'

        // this next command will show you the keys currently in
        // redis. You should see "lock.2"

    redis-cli> keys *

        // this command will show the value for the key "lock.2". This
        // will be the name of the worker who won the lock

    redis-cli> get "lock.2"
                </code></pre>

            </section>

            <section>
                <h2>Part 4</h2>
                A Live Competition!
<br><br>
    If your code has errors, start with the files from directory
    <b><p> /act-1-network-services/begin-part-4/ </p></b>
            </section>

            <section>
                <h3>Host: 54.191.82.237</h3>
                <h3>Port: 6379</h3>
                <br><br>
                <p>Everyone connect with a unique worker name</p>
                <br>
                <p>We'll dispatch a notification, and see which worker wins!</p>
            </section>

            <section>
                <h2>Let's scale</h2>
                <br>
                Fire up multiple workers (be sure to give them different names), and watch them race!
            </section>

            <section>
                <h2>Final Step</h2>
                Call a function to send a notification...
                <pre><code class="javascript">
    function lockCallback(data) {
        if(data.acquired == true) {
            console.log("I got the lock!");

            // send notification!
            sendMessage(data);
        }
        else console.log("No lock for me :(");
    }
                </code></pre>
            </section>
            <section>
                <h3>Final Step ..send some SMTP</h3>
                <pre class="stretch"><code class="javascript">
function sendMessage(payload) {
    console.log("Sending email notification...");
    var smtpTransport = mailer.createTransport("SMTP",{
        service: "Gmail",
        auth: {
          user: "&ltGoogle username>",
          pass: "&ltyour Google application-specific password>" }
    });
    var mailOptions = {
        from: "&ltemail&gt;", // sender address
        to: "&ltemail&gt;", // list of receivers
        subject: "Notification from Node.js", // Subject line
        text: "You are hereby notified!", // plaintext body
        html: "&lt;b&gt;You are hereby notified!&lt;/b&gt;" // html body
    };
    smtpTransport.sendMail(mailOptions, function(error, response){
        if(error) console.log("Error sending mail: " + error);
        else console.log("Message sent: " + response.message);
        smtpTransport.close(); // shut down the connection pool
    });
}
                </code></pre>
            </section>

            <!-- Act 2: Part 1: Basic Express -->

            <section>
                <h1>Act 2</h1>
                <h2>Part 1</h2>
                <h3>Basic Express</h3>
            </section>

            <section>
                <h2>Express</h2>
                <h3>A lightweight web framework for Node.js</h3>
            </section>

            <section>
                <h2>three files, 17 lines of code</h2>
                <h3>app.js, package.json, README.md</h3>
            </section>

            <section>
                <h2>Step 1: Create package.json:</h2>
                <small>* - Watch for spaces in "name". Express doesn't like them.</small>
                <pre><code class="json">
                    {
                      "name": "Express-Basic-Tutorial",
                      "description": "I'm learning nodejs express!",
                      "version": "0.0.1",
                      "private": true,
                      "dependencies": {
                        "express": "4.4.0"
                      }
                    }
                </code></pre>

                <h3>Hint</h3> To find the latest available version of a module
                <pre><code class="bash">
                    $ npm info express version
                </code></pre>
                Or you can simply say
                <pre><code class="json">
                    "express": "*"
                </code></pre>
            </section>

            <section>
                <h2>Step 2: Create README.md</h2>
                <small>This file needs some content for Express to be happy.</small>
                <pre><code class="markdown">
                    # Meet My App
                    App, audience. Audience, app.
                </code></pre>                
            </section>

            <section>
                <h2>Step 3: <strike>Profit</strike> Create app.js</h2>
                <pre><code class="javascript">
                    var express = require('express');
                    var app = express();

                    app.get('/', function(req,res){
                        res.send("hi there");
                    });

                    var server = app.listen(4000, function(){
                        console.log("Listening on 4000");
                    });
                </code></pre>
            </section>

            <section>
                <h2>Step 4: Install your dependencies</h2>
                <pre><code class="bash">
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h2>Step 5: Run it</h2>
                <pre><code class="bash">
                    $ node app.js
                </code></pre>
                <h4>and visit</h4>
                <h2>http://localhost:4000</h2>
            </section>

            <section>
                <h2>That was easy..</h2>
            </section>

            <section>
                <h1>Act 2</h1>
                <h2>Part 2</h2>
                <h3>Advanced Express</h3>
                (ooooooooh...)
            </section>

            <section>
                <h2>Surely, Express can do more</h2>
                <h3>Yes, it can. And with a little help.</h3>
                (and don't call me Shirley)
            </section>

            <section>
                <h2>Express Generator</h2>
                <pre><code class="bash">
                // install express generator
                $ npm install -g express-generator
                
                // create a new web application using ejs as the templating engine
                $ express -e ejs myapp
                
                // change into the new web app folder
                $ cd webapp
                
                // install dependencies
                $ npm install
                
                // start the server
                $ npm start
                </code></pre>
                <h4>(As Always, Run a command with '--help' and grok before executing)</h4>
                <h3>and visit</h3>
                <h2>http://localhost:3000</h2>
            </section>

            <section>
                <h2>visite du code</h2>
            </section>

            <section>
              <h2>app.js</h2>
              <pre><code>
var express = require('express');
var path = require('path');
var favicon = require('static-favicon');
var logger = require('morgan');
var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');

var routes = require('./routes/index');
var users = require('./routes/users');

var app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

app.use(favicon());
app.use(logger('dev'));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded());
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

app.use('/', routes);
app.use('/users', users);

/// catch 404 and forward to error handler
app.use(function(req, res, next) {
    var err = new Error('Not Found');
    err.status = 404;
    next(err);
});

/// error handlers

// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
    app.use(function(err, req, res, next) {
        res.status(err.status || 500);
        res.render('error', {
            message: err.message,
            error: err
        });
    });
}

// production error handler
// no stacktraces leaked to user
app.use(function(err, req, res, next) {
    res.status(err.status || 500);
    res.render('error', {
        message: err.message,
        error: {}
    });
});


module.exports = app;
              </code></pre>
            </section>

            <section>
              <h2>/bin/www</h2>
              <h3>bash script, includes app.js, runs server</h3>
              <h4>This is executed from within package.json..</h4>
              <pre><code>
#!/usr/bin/env node
var debug = require('debug')('newapp');
var app = require('../app');

app.set('port', process.env.PORT || 3000);

var server = app.listen(app.get('port'), function() {
  debug('Express server listening on port ' + server.address().port);
});
              </code></pre>
            </section>

            <section>
              <h2>package.json</h2>
              <h3>same old package.json</h3>
              <pre><code>
{
  "name": "newapp",
  "version": "0.0.1",
  "private": true, // disallows npm from publishing
  "scripts": {
    "start": "node ./bin/www" // you know this guy
  },
  "dependencies": {
    "express": "~4.2.0",
    "static-favicon": "~1.0.0",
    "morgan": "~1.0.0",
    "cookie-parser": "~1.0.1",
    "body-parser": "~1.0.0",
    "debug": "~0.7.4",
    "ejs": "~0.8.5"
  }
}
              </code></pre>
            </section>

            <section>
              <h2>/views/*.ejs</h2>
              <h3>example: index.ejs</h3>
              <h3>Note the &lt;%= .. %&gt; server tags</h3>
              <pre><code>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;
    &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
            </section>

            <section>
              <h2>/routes/*.js</h2>
              <h3>These are akin to controllers in MVC</h3>
              <h3>A route handler (callback) is associated with a request path</h3>
              <pre><code>
var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function(req, res) {
  res.render('index', { title: 'Express' });
});

module.exports = router;
              </code></pre>
            </section>

            <section>
              <h2>/public/stylesheets</h2>
              <h2>/public/javascripts</h2>
              <h2>/public/images</h2>
            </section>

            <section>
                <h2>Don't we need a database and models?</h2>
                <h3>Yes. We'll do that.</h3>
                <h3>But before we get into data and models, let's get familiar..</h3>
            </section>

            <section>
                <h2>Write a new view</h2>
                <h3>at /views/visits.ejs:</h3>
                <pre><code class="html">
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Page Visits&lt;/title&gt;
        &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Hi, <%= my_name %>&lt;/h1&gt;
        &lt;em&gt;we'll fill this in a minute..&lt;/em&gt;
      &lt;/body&gt;
    &lt;/html&gt;</code></pre>
                Again, note the &lt;%= .. %&gt;. This is data that will be filled in via ejs, and that data will come from our route handler.
            </section>

            <section>
                <h2>Write a route</h2>
                <h3>at /routes/visits.js:</h3>
                <pre><code class="javascript">
            var express = require('express');
            var router = express.Router();

            router.get('/', function(req, res) {
              res.render('visits', { my_name: "Tim" }); // -- find our view
            });

            module.exports = router;
                </code></pre>
                We provide data to the ejs templating engine in our render() call.
            </section>

            <section>
                <h2>Hook up requests with the route</h2>
                <h3>in app.js:</h3>
                <pre><code class="javascript">
            ...
            var routes = require('./routes/index');
            var users = require('./routes/users');
            var visits = require('./routes/visits'); // -- the route
            ...
            app.use('/', routes);
            app.use('/users', users);
            app.use('/visits', visits); // -- the request assignment
            ...
                </code></pre>
            </section>

            <section>
                <h3>restart your server and check out</h3>
                <h2>http://localhost:3000<b>/visits</b></h2>
            </section>

            <section>
                <h2>Right, back to the database and models</h2>
            </section>

            <section>
                <h2>First, add a bit to package.json for the mongo dependency</h2>
                <pre><code class="json">
                   ...
                    "debug": "~0.7.4",
                    "ejs": "~0.8.5",
                    "mongoose": "3.8.12"
                  }
                }
                </code></pre>
                <h3>and install</h3>
                <pre><code class="bash">
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h2>Create a new folder and file, /models/visit.js</h2>
                <pre><code class="javascript">
                var mongoose = require('mongoose')
                   ,Schema = mongoose.Schema
                   ,ObjectId = Schema.ObjectId;

                var visitSchema = new Schema({
                    thread: ObjectId,
                    date: {type: Date, default: Date.now},
                    user_agent: {type: String, default: 'none'}
                });

                module.exports = mongoose.model('Visit', visitSchema);
                </code></pre>
            </section>

            <section>
                <h2>And use that model to write data to mongo in app.js</h2>
                <pre><code class="javascript">
...
// -- this can go near the top                
var mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/myapp');
...
// -- bunch this with the other requires
var Visit = require("./models/visit.js");
...
// -- we run some code inline with each request - a new request decorator
// -- put this before the route handlers
app.use(function(req, res, next){
    new Visit({user_agent: req.headers['user-agent']}).save();
    next();
});

app.use('/', routes);
app.use('/users', users);
app.use('/visits', visits); // -- the request assignment
...
                </code></pre>
            </section>

            <section>
                <h2>careful</h2>
                <h3>Now that our app will try to talk to a database, that database will need to be running</h3>
                <pre><code class="bash">
                    # in a Mac OS X terminal
                    $ mongod --config /usr/local/etc/mongod.conf
                </code></pre>
            </section>

            <section>
                <h3>restart your server and check out</h3>
                <h2>http://localhost:3000<b>/visits</b></h2>
            </section>

            <section>
                <h2>I'm writing to a database, but I can't see my data!</h2>
                <img src="images/drwho.gif" />
                <h3>Let's fix that.</h3>
            </section>

            <section>
                <h2>Modify the route visits.js to fetch the data</h2>
                <h3>Don't forget to pass visits to your view!</h3>
                <pre><code class="javascript">
..

var Visit = require("../models/visit.js"); // -- new require

router.get('/', function(req, res) {

  var query = Visit.find(); // -- only creating a query object
  query.sort({date: -1}); // -- no execution here

  // -- we still have a render() call
  // -- but it is now in the callback to our database query execution
  query.exec(function(err, visits){
    // -- also note we are passing the results of our query to ejs
    res.render('visits', { my_name: "Tim", visits: visits });
  });
});
..
                </code></pre>
            </section>

            <section>
                <h2>And modify the view visits.ejs to render data</h2>
                <pre><code class="html">
            ..
            &lt;h1&gt;Hi, <% my_name %>&lt;/h1&gt;
            &lt;h2&gt;Look who's visiting your site!&lt;/h2&gt;
            &lt;% for(var v in visits){ %&gt;
              &lt;p&gt;&lt;%- visits[v].user_agent %&gt;&lt;/p&gt;
            &lt;% } %&gt;
            ..
                </code></pre>
            </section>

            <section>
                <h3>restart your server and check out</h3>
                <h2>http://localhost:3000<b>/visits</b></h2>
                (keep refreshing, you'll see it)
            </section>

            <section>
                <h2>Socket.IO</h2>
                <h3>The final frontier</h3>
                (cue music)
            </section>

            <section>
                <h2>Firstly, what is Socket.IO?</h2>
                <h3>A Node JS module which provides bi-directional socket communication between client and server</h3>
            </section>

            <section>
                <h2>What makes it different from regular web traffic over port 80?</h2>
                <h3>Socket.IO establishes a <b style='color:00c0c0;'>persistent</b> open socket over which <b style='color:00c0c0;'>both server and client</b> can freely initiate communicate with each other</h3>
            </section>

            <section>
                <h2>What does Socket.IO have to do with Express?</h2>
                <h3>Socket.IO is its own thing, and neither Socket.IO nor Express need each other. But Socket.IO integrates with Express so easily that we just had to show it.</h3>
            </section>

            <section>
                <h2>Let's try it</h2>
                <h3>First, set up your dependency</h3>
                <pre><code class="json">
                    ...
                        "debug": "~0.7.4",
                        "ejs": "~0.8.5",
                        "mongoose": "3.8.12",
                        "socket.io": "1.0.3"
                      }
                    }
                </code></pre>
                <h3>And install</h3>
                <pre><code class="bash">
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h3>Socket.IO runs as its own server, alongside our Express app</h3>
                <p>Put this snippet near the top of app.js, after 'app' is defined.</p>
                <pre><code class="javascript">
                    var server = require('http').createServer(app);
                    var io = require('socket.io').listen(server);
                    server.listen(3001);
                </code></pre>
            </section>

            <section>
                <h3>We define "endpoints", or "namespaces" for the server, much like routes.</h3>
                <p>Here, '/chat' is the namespace.</p>
                <p>Put this snippet somewhere after 'io' is defined in app.js.</p>
                <pre><code class="javascript">
            var chat = io.of('/chat').on('connection', function(socket){
                socket.on('chat', function(data){
                    data.color = 'green';
                    socket.emit('chat', data);
                    data.color = 'red';
                    socket.broadcast.emit('chat', data);
                });
            });
                </code></pre>
            </section>

            <section>
                <h3>This is just an HTML form, which will help us interact with the server from the client</h3>
                <p>This snippet goes in index.ejs somewhere in the BODY tag..</p>
                <pre><code class="html">
        &lt;div id="chatlog" style="height: 200px;overflow-y:scroll;"&gt;&lt;/div&gt;
        &lt;textarea id="chatwindow" cols="30" rows="10"&gt;&lt;/textarea&gt;
        &lt;input id="send_chat" type="submit" value="Send" /&gt;
                </code></pre>
            </section>

            <section>
                <h3>Also in index.ejs in the HEAD tag we'll put our client-side javascript, which connects to, reacts to, and sends messages to the server</h3>
                
                <pre><code class="html">
        &lt;script src="http://localhost:3001/socket.io/socket.io.js"&gt;&lt;/script&gt;
        &lt;script src="//code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt;

        &lt;script type="text/javascript"&gt;

            var chat_socket = io.connect('http://localhost:3001/chat');

            chat_socket.on('chat', function(data){
                $("#chatlog")
                    .append(
                        $("&lt;p style='color:" + data.color + ";'&gt;&lt;/p&gt;")
                            .text(data.isay)
                    );
            });

            $(document).on('click', "#send_chat", function(e){
                chat_socket.emit('chat', {isay: $("#chatwindow").val()});
                $("#chatwindow").val("");
            });

        &lt;/script&gt;
                </code></pre>
            </section>

            <section>
                <h3>restart your server and check out</h3>
                <h2>http://localhost:3000/index</h2>
                <h3>Try opening a few browser windows!</h3>
            </section>

            <!-- Act 3: Meteor.js and Reactive Apps -->
            <section>
                <h1>Act 3 (Denouement)</h1>
                <h2>Meteor</h2>
            </section>

            <section>
                <h1>Meteor</h1>
                <h3>A web app framework for real-time, reactive apps</h3>
                <h3>* powered by Node.js</h3>
            </section>
            <section>
                <h1>Real-time</h1>
                <h3>Server pushes data to all clients, immediately</h3>
            </section>
            <section>
                <h1>Reactive</h1>
                <h3>Changes on any client are immediately pushed to all other clients</h3>
            </section>
            <section>
                <h1>Slick, huh?</h1>
            </section>
            <section>
                <h2>Meteor is designed for single page apps</h2><br>
                <h4>So, no routing or multiple views out of the box</h4>
                (Though you can add them with packages)
            </section>
            <section>
                <h2>Let's check it out</h2>
                <h3>Install Meteor, and create a new dir</h3>
                <pre><code class="bash">
                $ npm install meteor -g
                $ mkdir node-act3
                $ cd node-act3
                </code></pre>
            </section>
            <section>
                <h2>Meteor has a generator, too!</h2>
                <pre><code class="bash">
                $ meteor create mapit
                $ cd mapit
                $ meteor
                </code></pre>
                <h4>Run "meteor --help" if you want to see behind the curtain</h4>

                <h3>and visit</h3>
                <h2>http://localhost:3000</h2>
            </section>
            <section>
                <h2>You'll notice that meteor claims it has started MongoDB</h2>
                <br>
                <h4>...even if you don't have MongoDB installed...</h4>
            </section>
            <section>
                <h1>That's because </h1><h1>Meteor is a liar!</h1>
            </section>
            <section>
                <h2>Just kidding!</h2>
                <h3>It's really because meteor has installed its own</h3><h3> embedded instance of Mongodb</h3>
                <br>
                <h4>You can access it anytime using:</h4>
                <pre><code class="bash">
                $ meteor mongo
                </code></pre>
            </section>
            <section>
                <h2>Let's check out the generated code</h2>
            </section>
            <section>
                <h2>Fibers</h2>
                <h3>Meteor uses a node.js library called <em>fibers</em>,</h3>
                <h3>which allows sequential execution of async functions, without callbacks</h3>
            </section>
            <section>
                <h2>We don't have time to go into how fibers works, but it's pretty cool</h2>
                <br>
                <h4>If you want to learn more: </h4>
                http://howtonode.org/generators-vs-fibers
                http://meteorhacks.com/fibers-eventloop-and-meteor.html
            </section>
            <section>
                <h2>This means meteor apps are straightforward to program</h2>
                <br>
                <h3>At the cost of some "framework magic"</h3>
            </section>
            <section>
                <h2>Meteor uses 3 default files:</h2>
                <ul>
                    <li>mapit.js -- client javascript and server code-behind</li>
                    <li>mapit.css -- styles</li>
                    <li>mapit.html -- client template/view</li>
                </ul>
            </section>
            <section>
                <h2>You'll see two sections in the mapit.js file:</h2>
                <pre><code class="javascript">
                    if (Meteor.isClient) {
                        ...
                    }
                    if (Meteor.isServer) {
                        ...
                    }
                </code></pre>
            </section>
            <section>
                <h3>Any code outside these sections is <em>shared</em> between client and server</h3>
                <br>
                <h3>That's the beauty of an all-JavaScript app</h3>
            </section>
            <section>
                <h2>Collections</h2>
                <h4>Meteor stores data as javascipt objects in MongoDB collections</h4>
                <img src="./images/mongo_collections.png" width="80%"></img>
            </section>
            <section>
                <h2>But forget about HTTP POSTS or AJAX</h2>
                <br>
                <h3>With meteor you don't need them. Meteor handles all data synchronization between client and server</h3>
                <br>
                <h3>Collections are accessed as reactive streams of data</h3>
            </section>
            <section>
                <h1>Check this out</h1>
                <br>
                <h2>mapit.js:</h2>
                <pre><code class="javascript">
                    Messages = new Meteor.collection('messages');
                    if (Meteor.isClient) {

                    }
                    if (Meteor.isServer) {
                        Meteor.startup(function () {
                            Messages.insert({'text': 'First message'});
                            Messages.insert({'text': 'Here\'s another'});
                        }

                        Meteor.publish("markers", function () {
                            return Markers.find();
                        });
                    }
                </code></pre>
            </section>
            <section>

            </section>
            <section>

            </section>
            <section>

            </section>
            <section>

            </section>

        </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
        // Required, even if empty.
        Reveal.initialize({
            controls: true,
  		    progress: true,
  			history: true,
  			center: true,
            slideNumber: true,

			theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
			transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

			// Parallax scrolling
			// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
			// parallaxBackgroundSize: '2100px 900px',

			// Optional libraries used to extend on reveal.js
			dependencies: [
				{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
				{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
			]
        });
    </script>
</body>
</html>
