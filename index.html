<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Reveal.js 3 Slide Demo</title>
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <!--Add support for earlier versions of Internet Explorer -->
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
    <!-- Wrap the entire slide show in a div using the "reveal" class. -->
    <div class="reveal">
        <!-- Wrap all slides in a single "slides" class -->
        <div class="slides">

            <!-- Introduction -->
            <section>
                <h1>Node.js Three Ways</h1>
                <h2>A Tutorial in Three Acts</h2>
                <p>Constantine Aaron Cois and Tim Palko</p>
            </section>

            <section id="slide2">
                <h1>Node.js!</h1>
                <p>What's the big deal?</p>
            </section>

            <section>
                <h2>Cool things that Node is</h2>
                    <ul>
                      <li> JavaScript</li>
                      <li> Server-side</li>
                      <li> Event-driven</li>
                      <li> Really fast and efficient</li>
                    </ul>
            </section>

            <section>
              <h3>This means you can...</h3>
              <br>
              <img src="./images/write_all_the_code_in_javascript1.jpg"></img>
            </section>
            <section>
              <h2>Let's talk <em>speed</em></h2>
              <br>
              <h3>Node.js was designed for highly-concurrent network applications</h3>
              <h4>(Read: scalable web apps, among other things)</h4>
            </section>
            <section>
              <h2>Under the hood, Node uses Gooogle Chrome's V8 engine</h2>
              
            </section>


            <!-- Act 1: Node.js Network Services -->
            <section>
                <h1>Act 1</h1>
                <h2>Node.js Network Services</h2>
            </section>

            <section>
                <h2>We're going to build a scalable, real-time notification service</h2>
            </section>

            <section>
                <h2>Make sure you have Node.js installed</h2>
            </section>

            <section>
                <h2>Create a project directory and code file</h2>
                <pre><code data-trim>
                  $ mkdir node-act1
                  $ cd node-act1
                  $ touch worker.js
                </code></pre>

                worker.js will be our asynchronous notification worker
            </section>

            <section>
                <h2>A first test</h2>

                Put the following in worker.js:
                <pre><code data-trim>
                  console.log("Hello OSCON!");
                </code></pre>

                ...and run it:
                <pre><code data-trim>
                  $ node worker.js
                </code></pre>
            </section>

            <!-- Act 2: Part 1: Basic Express -->

            <section>
                <h1>Act 2</h1>
                <h2>Part 1</h2>
                <h3>Basic Express</h3>
            </section>

            <section>
                <h2>Express</h2>
                <h3>A lightweight web framework for Node.js</h3>
            </section>

            <section>
                <h2>three files, 17 lines of code</h2>
                <h3>app.js, package.json, README.md</h3>
            </section>

            <section>
                <h2>Step 1: Create package.json:</h2>
                <pre><code data-trim>
                    {
                      "name": "Express Basic Tutorial",
                      "description": "I'm learning nodejs express!",
                      "version": "0.0.1",
                      "private": true,
                      "dependencies": {
                        "express": "4.4.0"
                      }
                    }
                </code></pre>

                <h3>Hint</h3> To find the latest available version of a module
                <pre><code data-trim>
                    $ npm info express version
                </code></pre>
                Or you can simply say
                <pre><code data-trim>
                    "express": "*"
                </code></pre>
            </section>

            <section>
                <h2>Step 2: Create README.md</h2>
                <pre><code data-trim>
                    # Meet My App
                    App, audience. Audience, app.
                </code></pre>
                (this file needs something in it for Express to be happy)
            </section>

            <section>
                <h2>Step 3: <strike>Profit</strike> Create app.js</h2>
                <pre><code data-trim>
                    var express = require('express');
                    var app = express();

                    app.get('/', function(req,res){
                        res.send("hi there");
                    });

                    var server = app.listen(4000, function(){
                        console.log("Listening on 4000");
                    });
                </code></pre>
            </section>

            <section>
                <h2>Step 4: Install your dependencies</h2>
                <pre><code data-trim>
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h2>Step 5: Run it</h2>
                <pre><code data-trim>
                    $ node app.js
                </code></pre>
                <h4>and visit</h4>
                <h2>http://localhost:4000</h2>
            </section>

            <section>
                <h2>That was easy..</h2>
            </section>

            <section>
                <h1>Act 2</h1>
                <h2>Part 2</h2>
                <h3>Advanced Express</h3>
                (ooooooooh...)
            </section>

            <section>
                <h2>Surely, Express can do more</h2>
                <h3>Yes, it can. And with a little help.</h3>
                (and don't call me Shirley)
            </section>

            <section>
                <h2>Express Generator</h2>
                <pre><code data-trim>
                $ npm install -g express-generator
                $ express -e ejs myapp
                $ npm install
                $ npm start
                </code></pre>
                <h3>Please</h3>
                <h4>Run "express --help" to see what options are available and grok what you're running</h4>
                <h3>and visit</h3>
                <h2>http://localhost:3000</h2>
            </section>

            <section>
                <h2>visite du code</h2>
            </section>

            <section>
                <h2>Don't we need a database, and controllers, and models?</h2>
                <h3>Yes. Let's do that.</h3>
                <h4>Actually, routes are "controllers", so one down and two to go.</h4>
            </section>

            <section>
                <h2>Before we get into data and models</h2>
                <h3>Let's get familiar</h3>
            </section>

            <section>
                <h2>Write a view</h2>
                <h3>at /views/visits.ejs:</h3>
                <pre><code data-trim>
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Page Visits&lt;/title&gt;
        &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Hi, {% my_name %}&lt;/h1&gt;
        &lt;em&gt;we'll fill this in a minute..&lt;/em&gt;
      &lt;/body&gt;
    &lt;/html&gt;</code></pre>
                Note the {% .. %}. This is data that will be filled in via ejs, and that data will come from our route handler.
            </section>

            <section>
                <h2>Write a route</h2>
                <h3>at /routes/visits.js:</h3>
                <pre><code data-trim>
            var express = require('express');
            var router = express.Router();

            router.get('/', function(req, res) {
              res.render('visits', { my_name: "Tim" }); // -- find our view
            });

            module.exports = router;
                </code></pre>
                We provide data to the ejs templating engine in our render() call.
            </section>

            <section>
                <h2>Hook up requests with the route</h2>
                <h3>in app.js:</h3>
                <pre><code data-trim>
            ...
            var routes = require('./routes/index');
            var users = require('./routes/users');
            var visits = require('./routes/visits'); // -- the route
            ...
            app.use('/', routes);
            app.use('/users', users);
            app.use('/visits', visits); // -- the request assignment
            ...
                </code></pre>
            </section>

            <section>
                <h3>again, let us visit</h3>
                <h2>http://localhost:3000<b>/visits</b></h2>
            </section>

            <section>
                <h2>Right, back to the database and models</h2>
            </section>

            <section>
                <h2>First, add a bit to package.json for the mongo dependency</h2>
                <pre><code data-trim>
                   ...
                    "debug": "~0.7.4",
                    "ejs": "~0.8.5",
                    "mongoose": "3.8.12"
                  }
                }
                </code></pre>
                <h3>and install</h3>
                <pre><code data-trim>
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h2>a model, visit.js, in /models</h2>
                <pre><code data-trim>
                var mongoose = require('mongoose')
                   ,Schema = mongoose.Schema
                   ,ObjectId = Schema.ObjectId;

                var visitSchema = new Schema({
                    thread: ObjectId,
                    date: {type: Date, default: Date.now},
                    user_agent: {type: String, default: 'none'}
                });

                module.exports = mongoose.model('Visit', visitSchema);
                </code></pre>
            </section>

            <section>
                <h2>using that model to write data to mongo in app.js</h2>
                <pre><code data-trim>
            var mongoose = require('mongoose');
            mongoose.connect('mongodb://localhost/myapp');

            var Visit = require("./models/visit.js");

            // -- we run some code inline with each request
            app.use(function(req, res, next){
                new Visit({user_agent: req.headers['user-agent']}).save();
                next();
            });
                </code></pre>
            </section>

            <section>
                <h2>careful</h2>
                <h3>Now that our app will try to talk to a database, that database will need to be running</h3>
                <pre><code data-trim>
                    $ mongod --config /usr/local/etc/mongod.conf
                </code></pre>
            </section>

            <section>
                <h2>I'm writing to a database, but I can't see my data!</h2>
                <h3>Let's fix that.</h3>
            </section>

            <section>
                <h2>Modify the route to fetch the data</h2>
                <pre><code data-trim>
            ..
            var Visit = require("../models/visit.js");

            router.get('/', function(req, res) {

              var query = Visit.find();
              query.sort({date: -1});

              query.exec(function(err, visits){
                res.render('visits', { my_name: "Tim", visits: visits });
              });
            });
            ..
                </code></pre>
            </section>

            <section>
                <h2>And modify the view to render it</h2>
                <pre><code data-trim>
            ..
            &lt;h1&gt;Hi, {% my_name %}&lt;/h1&gt;
            &lt;% for(var v in visits){ %&gt;
              &lt;p&gt;&lt;%- visits[v] %&gt;&lt;/p&gt;
            &lt;% } %&gt;
            ..
                </code></pre>
            </section>

            <section>
                <h3>once more, let us visit</h3>
                <h2>http://localhost:3000<b>/visits</b></h2>
                (keep refreshing, you'll see it)
            </section>

            <section>
                <h2>Socket.IO</h2>
                <h3>The final frontier</h3>
                (cue music)
            </section>

            <section>
                <h2>Firstly, what is Socket.IO?</h2>
                <h3>A Node JS module which provides bi-directional socket communication between client and server</h3>
            </section>

            <section>
                <h2>What makes it different from regular web traffic over port 80?</h2>
                <h3>Socket.IO establishes a <b style='color:00c0c0;'>persistent</b> open socket over which <b style='color:00c0c0;'>both server and client</b> can freely initiate communicate with each other</h3>
            </section>

            <section>
                <h2>What does Socket.IO have to do with Express?</h2>
                <h3>Socket.IO is its own thing, and neither Socket.IO nor Express require each other. But Socket.IO integrates with Express so easily that we just had to show it.</h3>
            </section>

            <section>
                <h2>Let's try it</h2>
                <h3>First, set up your dependency</h3>
                <pre><code data-trim>
                    ...
                        "debug": "~0.7.4",
                        "ejs": "~0.8.5",
                        "mongoose": "3.8.12",
                        "socket.io": "1.0.3"
                      }
                    }
                </code></pre>
                <h3>And install</h3>
                <pre><code data-trim>
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h3>Socket.IO runs as its own server, alongside our Express app</h3>
                <pre><code data-trim>
                    var server = require('http').createServer(app);
                    var io = require('socket.io').listen(server);
                    server.listen(3001);
                </code></pre>
                (put this in app.js)
            </section>

            <section>
                <h3>We define "endpoints", or "namespaces" for the server, much like routes.</h3>
                <pre><code data-trim>
            // -- '/chat' is the namespace identifier
            // -- the callback function is the middleware we define
            // -- for the namespace identifier
            var chat = io.of('/chat').on('connection', function(socket){
                socket.on('chat', function(data){
                    data.color = 'green';
                    socket.emit('chat', data);
                    data.color = 'red';
                    socket.broadcast.emit('chat', data);
                });
            });
                </code></pre>
                (also put this in app.js)
            </section>

            <section>
                <h3>This is just an HTML form, which will help us interact with the server from the client</h3>
                <pre><code data-trim>
        &lt;div id="chatlog" style="height: 200px;overflow-y:scroll;"&gt;&lt;/div&gt;
        &lt;textarea id="chatwindow" cols="30" rows="10"&gt;&lt;/textarea&gt;
        &lt;input id="send_chat" type="submit" value="Send" /&gt;
                </code></pre>
                (this goes in our visits.ejs view)
            </section>

            <section>
                <h3>Here is our client-side javascript, which connects to, reacts to, and sends messages to the server</h3>
                <pre><code data-trim>
        &lt;script src="http://localhost:3001/socket.io/socket.io.js"&gt;&lt;/script&gt;
        &lt;script src="//code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt;

        &lt;script type="text/javascript"&gt;

            var chat_socket = io.connect('http://localhost:3001/chat');

            chat_socket.on('chat', function(data){
                $("#chatlog")
                    .append(
                        $("&lt;p style='color:" + data.color + ";'&gt;&lt;/p&gt;")
                            .text(data.isay)
                    );
            });

            $(document).on('click', "#send_chat", function(e){
                chat_socket.emit('chat', {isay: $("#chatwindow").val()});
                $("#chatwindow").val("");
            });

        &lt;/script&gt;
                </code></pre>
            </section>

            <!-- Act 3: Meteor.js and Reactive Apps -->
            <section>
                <h1>Act 3 (Denouement)</h1>
                <h2>Meteor</h2>
            </section>

            <section>
                <h1>Meteor</h1>
                <h3>A web app framework for real-time, reactive apps</h3>
                <h3>* powered by Node.js</h3>
            </section>
            <section>
                <h1>Real-time</h1>
                <h3>Server pushes data to all clients, immediately</h3>
            </section>
            <section>
                <h1>Reactive</h1>
                <h3>Changes on any client are immediately pushed to all other clients</h3>
            </section>
            <section>
                <h1>Slick, huh?</h1>
            </section>
            <section>
                <h2>Meteor is designed for single page apps</h2><br>
                <h4>So, no routing or multiple views out of the box</h4>
                (Though you can add them with packages)
            </section>
            <section>
                <h2>Let's check it out</h2>
                <h3>Install Meteor, and create a new dir</h3>
                <pre><code data-trim>
                $ npm install meteor -g
                $ mkdir node-act3
                $ cd node-act3
                </code></pre>
            </section>
            <section>
                <h2>Meteor has a generator, too!</h2>
                <pre><code data-trim>
                $ meteor create mapit
                $ meteor
                </code></pre>
                <h4>Run "meteor --help" if you want to see behind the curtain</h4>

                <h3>and visit</h3>
                <h2>http://localhost:3000</h2>
            </section>
            <section>
                <h2>You'll notice that meteor claims it has started MongoDB</h2>
                <br>
                <h4>...even if you don't have MongoDB installed...</h4>
            </section>
            <section>
                <h1>That's because </h1><h1>Meteor is a liar!</h1>
            </section>
            <section>
                <h2>Just kidding!</h2>
                <h3>It's really because meteor has installed its own</h3><h3> embedded instance of Mongodb</h3>
                <br>
                <h4>You can access it anytime using:</h4>
                <pre><code data-trim>
                $ meteor mongo
                </code></pre>
            </section>
            <section>
                <h2>Let's check out the generated code</h2>
            </section>
            <section>
                <h2>Fibers</h2>
                <h3>Meteor uses a node.js library called <em>fibers</em>,</h3>
                <h3>which allows sequential execution of async functions, without callbacks</h3>
            </section>
            <section>
                <h2>We don't have time to go into how fibers works, but it's pretty cool</h2>
                <br>
                <h4>If you want to learn more: </h4>
                http://howtonode.org/generators-vs-fibers
                http://meteorhacks.com/fibers-eventloop-and-meteor.html
            </section>
            <section>
                <h2>This means meteor apps are straightforward to program</h2>
                <br>
                <h3>At the cost of some "framework magic"</h3>
            </section>
            <section>
                <h2>Meteor uses 3 default files:</h2>
                <ul>
                    <li>mapit.js -- client javascript and server code-behind</li>
                    <li>mapit.css -- styles</li>
                    <li>mapit.html -- client template/view</li>
                </ul>
            </section>
            <section>
                <h2>You'll see two sections in the mapit.js file:</h2>
                <pre><code data-trim>
                    if (Meteor.isClient) {
                        ...
                    }
                    if (Meteor.isServer) {
                        ...
                    }
                </code></pre>
            </section>
            <section>
                <h3>Any code outside these sections is <em>shared</em> between client and server</h3>
                <br>
                <h3>That's the beauty of an all-JavaScript app</h3>
            </section>
            <section>
                <h2>Collections</h2>
                <h4>Meteor stores data as javascipt objects in MongoDB collections</h4>
                <img src="./images/mongo_collections.png" width="80%"></img>
            </section>
            <section>
                <h2>But forget about HTTP POSTS or AJAX</h2>
                <br>
                <h3>With meteor you don't need them. Meteor handles all data synchronization between client and server</h3>
                <br>
                <h3>Collections are accessed as reactive streams of data</h3>
            </section>
            <section>
                <h1>Check this out</h1>
                <br>
                <h2>mapit.js:</h2>
                <pre><code data-trim>
                    Messages = new Meteor.collection('messages');
                    if (Meteor.isClient) {

                    }
                    if (Meteor.isServer) {
                        Meteor.startup(function () {
                            Messages.insert({'text': 'First message'});
                            Messages.insert({'text': 'Here\'s another'});
                        }

                        Meteor.publish("markers", function () {
                            return Markers.find();
                        });
                    }
                </code></pre>
            </section>
            <section>

            </section>
            <section>

            </section>
            <section>

            </section>
            <section>

            </section>

        </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
        // Required, even if empty.
        Reveal.initialize({
          transition: 'default'
        });
    </script>
</body>
</html>
