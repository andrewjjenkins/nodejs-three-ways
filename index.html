<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Node.js Three Ways</title>

    <meta name="description" content="An OSCON 20214 Workshop. Learn to create Node.js applications using three approaches: vanilla Node.js for network services, Express MVC applications, and Reactive applications using Meteor">
		<meta name="author" content="Constantine Aaron Cois and Tim Palko">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>
    <!-- Wrap the entire slide show in a div using the "reveal" class. -->
    <div class="reveal">
        <!-- Wrap all slides in a single "slides" class -->
        <div class="slides">

            <!-- Introduction -->
            <section>
                <h2>Before we get started, Install These:</h2>
                <br>
                <div class="column" style="float: left;margin: 0;width: 29%;">
                    <h4>OSX</h4>
                    <pre><code class="bash">
(if you have homebrew)

$ brew install node
$ brew install redis
$ brew install mongo
                    </code></pre>

                </div>
                <div class="column" style="float: left;margin: 0;width: 40%;">
                    <h4>Ubuntu/Debian</h4>
                    <pre><code class="bash">
(use sudo if necessary)

$ apt-get install nodejs
$ apt-get install redis-server
$ apt-get install mongodb
$ apt-get install npm
                    </code></pre>
                </div>
                <div class="column" style="float: left;margin: 0;width: 31%;">
                    <h4>Windows</h4>
                    <pre><code class="bash">
(using chocolatey)

> cinst nodejs.install
> cinst redis
> cinst mongodb
                    </code></pre>
                </div>

<br><br>
<p style="clear:both;">or for manual install instructions, go to:</p>
<a href="http://www.nodejs.org">http://nodejs.org</a> |
<a href="http://www.mongodb.org/downloads">http://mongodb.org</a> |
<a href="http://redis.io/download">http://redis.io</a>
<br>
<br><p>And clone the workshop repo:</p>
<pre><code class="javascript">
        $ git clone https://github.com/cacois/nodejs-three-ways

</code></pre>
            </section>

            <section>
                <h1>Node.js Three Ways</h1>
                <h2>A Tutorial in Three Acts</h2>
                <br>
                <p>Constantine Aaron Cois and Tim Palko</p>
                <p>Carnegie Mellon University, Software Engineering Institute</p>
                <br><p style="font-size: 11pt">Disclaimer: Though we are employees of the Software Engineering Institute at Carnegie Mellon University, this wok was not funded by the SEI and does not reflect the work or opinions of the SEI or its customers.
</p>
            </section>

            <section>
                <h2>Aaron = </h2>
                <p style="text-align: left;margin-left: 300;">{</p>
                <p style="text-align: left;margin-left: 350;">twitter: <a href="https://twitter.com/aaroncois">@aaroncois</a>,</p>
                <p style="text-align: left;margin-left: 350;">blog: <a href="http://www.codehenge.net">www.codehenge.net</a>,</p>
                <p style="text-align: left;margin-left: 350;">github: <a href="http://github.com/cacois">http://github.com/cacois </a></p>
                <p style="text-align: left;margin-left: 300;">}</p>
                <br>
                <h2>Tim =</h2>
                <p style="text-align: left;margin-left: 300;">{</p>
                <p style="text-align: left;margin-left: 350;">twitter: <a href="https://twitter.com/timpalko">@timpalko</a>,</p>
                <p style="text-align: left;margin-left: 350;">github: <a href="http://github.com/tpalko">http://github.com/tpalko </a></p>
                <p style="text-align: left;margin-left: 300;">}</p>
            </section>
            <section>
                <h2>Code</h2>
                <b>Code</b> for this workshop can be found on github:
                <br><br>
                <h3><a href="https://github.com/cacois/nodejs-three-ways">https://github.com/cacois/nodejs-three-ways</a></h3>
                <br><br>
                <h2>Slides</h2>
                You can also find slides here:
                <br><br>
                <h3><a href="http://cacois.github.io/nodejs-three-ways/#/">http://cacois.github.io/nodejs-three-ways/#/</a></h3>
            </section>

            <section>
                <h1>The Basics</h1>
            </section>
            <section id="slide2">
                <h1>Node.js!</h1>
                <p>What's the big deal?</p>
            </section>

            <section>
                <h2>Cool things that Node is</h2>
                    <ul>
                      <li> JavaScript</li>
                      <li> Server-side</li>
                      <li> Event-driven</li>
                      <li> <em>Fast</em> and <em>Efficient</em></li>
                    </ul>
            </section>

            <section>
              <h2>JavaScript</h2>
              <br>
              <h3>This means you can...</h3>
              <br>
              <img src="./images/write_all_the_code_in_javascript1.jpg"></img>
            </section>

            <section>
              <h1>Advantages to JS</h1>
              <br><ul>
                  <li>Familiar</li>
                  <li>Low barrier to entry</li>
                  <li>Team Redundancy</li>
              </ul><br>
             <p>(Front-end devs and back-end devs speak the same language)</p>
            </section>

            <section>
              <h2>Let's talk <em>speed</em></h2>
              <br>
              <h3>Node.js was designed for highly-concurrent network applications</h3>
              <h4>(Read: scalable web apps, among other things)</h4>
            </section>

            <section data-background="./images/v8-logo.png"  data-background-size="80%">
              <h1 style="color:black">Fast</h1>
              <br>
              <br>
              <h3 style="color:black">Node uses the V8 JavaScript engine powering Google Chrome</h3><br>
              <h3 style="color:black">This means lightning fast JavaScript execution</h3>
            </section>

            <section>
              <h1>Efficient</h1>
              <h2>Node.js is <em>asynchronous</em> and <em>event-driven</em></h2>
              <br>
              <p>This means you have to think a bit differently</p>
            </section>

            <section data-background="./images/event-loop-1.png" data-background-size="70%"/>
            </section>

            <section data-background="./images/event-loop-2.png"  data-background-size="70%"/>
            </section>

            <section data-background="./images/event-loop-3.png"  data-background-size="70%"/>
            </section>

            <section>
              <h1>Callbacks</h1>
              <pre><code class="javascript">
                fs = require('fs');
 
                fs.readFile('f1.txt','utf8',function(err,data){
                  if (err) {
                    // handle error
                  }
                  console.log(data);
                });
              </code></pre>
            </section>

            <section>
              <h1>Callbacks</h1>
              <h3>Equivalent Syntax </h3>
              <pre><code class="javascript">
                fs = require('fs');
 
                fs.readFile('f1.txt','utf8',

                  function(err,data) {
                    if (err) {
                      // handle error
                    }
                    console.log(data);
                  }

                );
              </code></pre>
            </section>

            <section>
              <h2>Let's get to work</h2>
              <br>
              <p><a href="#/18">Act 1 - Node.js Network Services</a></p>
              <p><a href="#/51">Act 2 - Express Web Applications</a></p>
              <p><a href="#/95">Act 3 - Meteor Real-Time Applications</a></p>
            </section>

            <!-- Act 1: Node.js Network Services -->
            <section>
                <h1>Act 1</h1>
                <h2>Node.js Network Services</h2>
            </section>

            <section>
                <h2>We're going to build a scalable, real-time notification service</h2>
            </section>

            <section>
              <h2>Here's what it will look like</h2>
              <img class="stretch" src="./images/notification-system.png" />
            </section>

            <section>
                <h1>Part 1</h1>
            </section>

            <section>
                <h2>Create a project directory and file</h2>
                <pre><code class="bash">
                  $ mkdir node-act1
                  $ cd node-act1
                  $ touch worker.js
                </code></pre>

                worker.js will be our asynchronous notification worker
            </section>

            <section>
                <h2>A first test</h2>

                Put the following in worker.js:
                <pre><code class="javascript">
                  console.log("Hello OSCON!");
                </code></pre>

                ...and run it:
                <pre><code class="bash">
                  $ node worker.js
                </code></pre>
            </section>

            <section>
              <h2>Node Package Manager (NPM)</h2>
              <br>
              We will need to use some external packages for our app.
              <br><br>
              Specifically, we will need the Redis client package. Install it using:
              <pre><code class="bash">
                $ npm install redis
              </code></pre>
              The package will be installed in a local node_modules directory. Check it out:
              <pre><code class="bash">
                $ ls node_modules
              </code></pre>
            </section>

            <section>
                Now we can start by connecting to Redis to receive Pub/Sub messages
                <br><br>
                Add the following to worker.js:
                <pre><code class="javascript">
              // import the redis module
              var redis = require("redis");

              // create a redis client object
              var pubSubClient = redis.createClient('6379', 'localhost');

              // subscribe to 'notifications' collection
              pubSubClient.subscribe("notifications");

              // define message handler
              pubSubClient.on("message", function(channel, message) {
                  console.log('Received a message: ' + message);
              });
                </code></pre>
              </section>
              <section>
                Start the redis server in one window...
                <pre><code class="bash">
                  $ redis-server
                </code></pre>
                ...and run your app in another...
                <pre><code class="bash">
                  $ node worker.js
                </code></pre>
            </section>

            <section>
                Now let's test. Write to the collecion in Redis:
                <br><br>
                <pre><code class="bash">
  $ redis-cli

  redis-cli> publish notifications '{"identifier": 1, "message": "Huzzah!"}'
  (integer) 1
                </code></pre>
                <br>
                The value after (integer) tell you how many subscribers received the published message
            </section>

            <section>
                <pre><code class="bash">
                  $ node worker.js
                  Received a message: Huzzah!
                </code></pre>
                <br>
               <img src=./images/futurama-huzzah.jpg />
            </section>

            <section>
                <h1>Part 2</h1>
<br>
    If your code has errors, start with the files from directory
    <b><p> /act-1-network-services/begin-part-2/ </p></b>
            </section>

            <section>
              Now let's take a step back and set up some basic stuff for our project
            </section>

            <section>
                <h2>Config File</h2>
                <br>
                I like to use a module for config data. Create a file named config.js:
                <pre><code class="bash">
                  $ touch config.js
                </code></pre>
                .. and put the following content in it:
                <pre><code class="bash">
                module.exports = {
                  host: 'localhost',
                  port: 6379
                }
                </code></pre>
                The 'module.exports' value indicates what will be returned from a require(...) call to this file
            </section>

            <section>
              Now import the file into your worker.js app by adding the following to the top of the file:
              <pre><code class="javascript">
            var config = require("./config.js");
              </code></pre>
              Now we can replace the Redis client instantiation:
              <pre><code class="javascript">
            var pubSubClient = redis.createClient('6379', 'localhost');
              </code></pre>
              with:
              <pre><code class="javascript">
            var pubSubClient = redis.createClient(config.port, config.host);
              </code></pre>
              <br>
              Nifty!
            </section>

            <section>
              <h2>Package Management</h2>
              We've already seen how to install individual packages using NPM
              <br><br>
              But can we automate this, and centrally manage package requirements?
              <br><br>
              Yes, with a package.json file:
              <pre><code class="bash">
            $ touch package.json
              </code></pre>
            </section>

            <section>
              <h2>Package.json</h2>
              A lot of info can go into a package.json file
              <br><br>
              We'll only use a small bit of its functionality here. Write this:
              <pre><code class="json">
            {
              "name": "act-1-network-services",
              "author": "MY NAME &lt;my@email.com&gt;",
              "version": "1.0.0",
              "dependencies": {
                "redis": "*",
                "nodemailer": "*"
              },
              "engine": { "node" : ">=0.10.0" }
            }
              </code></pre>
              <p>This specifies:</p>
              <ul>
                <li>some metadata about the app</li>
                <li>a list of package dependencies (we'll need nodemailer later)</li>
                <li>a required Node version</li>
              </ul>

            </section>
            <section>
              <h2>NPM Install</h2>
              Now that we have a package.json, we can install the app and its dependencies in one command:
              <pre><code class="bash">
            $ npm install
              </code></pre>
              <p>NPM will look for a local package.json and use it to set everything up</p>
            </section>

            <section>
                <h1>Part 3</h1>
<br>
    If your code has errors, start with the files from directory
    <b><p> /act-1-network-services/begin-part-3/ </p></b>
            </section>

            <section>
                <h3>worker.js should look like this:</h2>
                <pre class="stretch"><code class="javascript" style="font-size: 13pt">


      // import the redis module
      var redis = require("redis");

      // read in the config file as a JavaScript object
      var config = require("./config.js");

      // create a redis client object
      var pubSubClient = redis.createClient(config.port, config.host);

      // subscribe to 'notifications' collection
      pubSubClient.subscribe("notifications");

      // define message handler
      pubSubClient.on("message", function(channel, message) {
          console.log('Received a message: ' + message);
      });
                </code></pre>
            </section>

            <section>
                Let's make that message handler function a bit more manageable
                <br><br>
                Move the closure out to a separtely defined function:
                <pre><code class="javascript">
            // define message handler
            pubSubClient.on("message", handleMessage);

            function handleMessage(channel, message) {
                console.log('Received a message: ' + message);
            }
                </code></pre>
            </section>

            <section>
                Now let's make it do something more interesting.
                <br><br>
                We want multiple, fault-tolerant workers to handle notifications. This will make our system scalable.
                <br><br>
                We can accomplish this by making all workers race to handle any notification dispatched - which means <em>locks</em>
            </section>
            <section>
                <h3>worker.js</h3>
                <pre><code class="javascript">
            ...
            // define message handler
            pubSubClient.on("message", handleMessage);

            function handleMessage(channel, message) {
                console.log('Received a message: ' + message);

                var payload = JSON.parse(message);

                acquireLock(payload, lockCallback);
            }
                </code></pre>

            Notice that we've identified two functions we need to write: <b>acquireLock</b> and the callback <b>lockCallback</b>
            </section>

            <section>
                <h2>acquireLock</h2>
                We can use Redis for locks, too. The first worker to write a lock for a given notification wins!
            </section>
            <section>
                <h3>worker.js</h3>
                <pre class="stretch"><code class="javascript">
...
var client = redis.createClient(config.port, config.host);
...
function acquireLock(payload, callback) {
    // create a lock id string
    var lockIdentifier = "lock." + payload.identifier;
    console.log("Trying to obtain lock: %s", lockIdentifier);

    client.setnx(lockIdentifier, "Worker Name", function(error, success) {
        if (error) {
            logger.error("Error acquiring lock for: %s", lockIdentifier);
            return callback(error, dataForCallback(false));
        }

        var data = {
            "acquired" : success,
            "lockIdentifier" : lockIdentifier,
            "payload" : payload };
        return callback(data);
    });
}
                </code></pre>

            </section>

            <section>
            <h2>You Are Special</h2>
                Give your worker a better name than "Worker Name"! Unique and memorable.
                <br><br>
                That way, if your worker acquires a lock on a central server, the lock can identify your worker.
                <br><br>(Protip: If you want to pass a worker name/id in from the command line, check out the <b>process.argv</b> object)
            </section>

            <section>
                <h2>lockCallback</h2>
                Now the callback after a worker tried to acquire a lock.
                <br><br>
                <h3>worker.js</h3>
                <pre><code class="javascript">
...
function lockCallback(data) {
    if(data.acquired == true) {
        console.log("I got the lock!");

        // send notification!
        // TODO: actually notify
        console.log('I win! Sending notification: %s',
                     JSON.stringify(data));
    }
    else console.log("No lock for me :(");
}
                </code></pre>
            </section>

            <section>
                We've written a lot of code - let's test
                <br><br>
                <pre class="stretch"><code class="bash">
    $ node worker.js
    (in another terminal)
    $ redis-cli

    redis-cli> publish notifications '{"identifier": 2, "message": "in a bottle"}'

        // this next command will show you the keys currently in
        // redis. You should see "lock.2"

    redis-cli> keys *

        // this command will show the value for the key "lock.2". This
        // will be the name of the worker who won the lock

    redis-cli> get "lock.2"
                </code></pre>

            </section>

            <section>
                <h2>Part 4</h2>
                A Live Competition!
<br><br>
    If your code has errors, start with the files from directory
    <b><p> /act-1-network-services/begin-part-4/ </p></b>
            </section>

            <section>
                <h3>Host: 54.191.82.237</h3>
                <h3>Port: 6379</h3>
                <br><br>
                <p>Everyone connect with a unique worker name</p>
                <br>
                <p>We'll dispatch a notification, and see which worker wins!</p>
            </section>

            <section>
                <h2>Let's scale</h2>
                <br>
                Fire up multiple workers (be sure to give them different names), and watch them race!
            </section>

            <section>
                <h2>Final Step</h2>
                Call a function to send a notification...
                <pre><code class="javascript">
    function lockCallback(data) {
        if(data.acquired == true) {
            console.log("I got the lock!");

            // send notification!
            sendMessage(data);
        }
        else console.log("No lock for me :(");
    }
                </code></pre>
            </section>
            <section>
                <h3>Final Step ..send some SMTP</h3>
                <pre class="stretch"><code class="javascript">
function sendMessage(payload) {
    console.log("Sending email notification...");
    var smtpTransport = mailer.createTransport("SMTP",{
        service: "Gmail",
        auth: {
          user: "&ltGoogle username>",
          pass: "&ltyour Google application-specific password>" }
    });
    var mailOptions = {
        from: "&ltemail&gt;", // sender address
        to: "&ltemail&gt;", // list of receivers
        subject: "Notification from Node.js", // Subject line
        text: "You are hereby notified!", // plaintext body
        html: "&lt;b&gt;You are hereby notified!&lt;/b&gt;" // html body
    };
    smtpTransport.sendMail(mailOptions, function(error, response){
        if(error) console.log("Error sending mail: " + error);
        else console.log("Message sent: " + response.message);
        smtpTransport.close(); // shut down the connection pool
    });
}
                </code></pre>
            </section>

            <!-- Act 2: Part 1: Basic Express -->

            <section>
                <h1>Act 2</h1>
                <h2>Part 1</h2>
                <h3>Basic Express</h3>
            </section>

            <section>
                <h2>Express</h2>
                <h3>A lightweight web framework for Node.js</h3>
            </section>

            <section>
                <h2>three files, 17 lines of code</h2>
                <h3>app.js, package.json, README.md</h3>
            </section>

            <section>
                <h2>Step 1: Create package.json:</h2>
                <small>* - Watch for spaces in "name". Express doesn't like them.</small>
                <pre><code class="json">
                    {
                      "name": "Express-Basic-Tutorial",
                      "description": "I'm learning nodejs express!",
                      "version": "0.0.1",
                      "private": true,
                      "dependencies": {
                        "express": "4.4.0"
                      }
                    }
                </code></pre>

                <h3>Hint</h3> To find the latest available version of a module
                <pre><code class="bash">
                    $ npm info express version
                </code></pre>
                Or you can simply say
                <pre><code class="json">
                    "express": "*"
                </code></pre>
            </section>

            <section>
                <h2>Step 2: Create README.md</h2>
                <small>This file needs some content for Express to be happy.</small>
                <pre><code class="markdown">
                    # Meet My App
                    App, audience. Audience, app.
                </code></pre>
            </section>

            <section>
                <h2>Step 3: <strike>Profit</strike> Create app.js</h2>
                <pre><code class="javascript">
                    var express = require('express');
                    var app = express();

                    app.get('/', function(req,res){
                        res.send("hi there");
                    });

                    var server = app.listen(3000, function(){
                        console.log("Listening on 3000");
                    });
                </code></pre>
            </section>

            <section>
                <h2>Step 4: Install your dependencies</h2>
                <pre><code class="bash">
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h2>Step 5: Run it</h2>
                <pre><code class="bash">
                    $ node app.js
                    Listening on 3000
                </code></pre>
                <h4>and visit</h4>
                <h2>http://localhost:3000</h2>

                <img src="images/act2part1_screenshot.png" />
            </section>

            <section>
                <h2>That was easy..</h2>
            </section>

            <section>
                <h1>Act 2</h1>
                <h2>Part 2</h2>
                <h3>Advanced Express</h3>
                (ooooooooh...)
            </section>

            <section>
                <h2>Surely, Express can do more</h2>
                <h3>Yes, it can. And with a little help.</h3>
                (and don't call me Shirley)
            </section>

            <section>
                <h2>Express Generator</h2>
                <pre><code class="bash">
// install express generator
$ npm install -g express-generator

// create a new web application using ejs as the templating engine
$ express -e ejs myapp

$ cd webapp
$ npm install
$ npm start

> bigwin@0.0.1 start /where/you/cloned/the/repo/nodejs-three-ways/act-2-part-2-advanced-express/begin-part-1/bigwin
> node ./bin/www
                </code></pre>
                <h3>and visit http://localhost:3000</h3>

                <img src="images/act2part2_begin1_screenshot.png" />
            </section>

            <section>
                <h2>visite du code</h2>
            </section>

            <section>
              <h2>app.js</h2>
              <pre><code>
var express = require('express');
var path = require('path');
var favicon = require('static-favicon');
var logger = require('morgan');
var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');

var routes = require('./routes/index');
var users = require('./routes/users');

var app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

app.use(favicon());
app.use(logger('dev'));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded());
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

app.use('/', routes);
app.use('/users', users);

/// catch 404 and forward to error handler
app.use(function(req, res, next) {
    var err = new Error('Not Found');
    err.status = 404;
    next(err);
});

/// error handlers

// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
    app.use(function(err, req, res, next) {
        res.status(err.status || 500);
        res.render('error', {
            message: err.message,
            error: err
        });
    });
}

// production error handler
// no stacktraces leaked to user
app.use(function(err, req, res, next) {
    res.status(err.status || 500);
    res.render('error', {
        message: err.message,
        error: {}
    });
});


module.exports = app;
              </code></pre>
            </section>

            <section>
              <h2>/bin/www</h2>
              <h3>bash script, includes app.js, runs server</h3>
              <h4>This is executed from within package.json..</h4>
              <pre><code>
#!/usr/bin/env node
var debug = require('debug')('newapp');
var app = require('../app');

app.set('port', process.env.PORT || 3000);

var server = app.listen(app.get('port'), function() {
  debug('Express server listening on port ' + server.address().port);
});
              </code></pre>
            </section>

            <section>
              <h2>package.json</h2>
              <h3>same old package.json</h3>
              <pre class="stretch"><code>
{
  "name": "newapp",
  "version": "0.0.1",
  "private": true, // disallows npm from publishing
  "scripts": {
    "start": "node ./bin/www" // you know this guy
  },
  "dependencies": {
    "express": "~4.2.0",
    "static-favicon": "~1.0.0",
    "morgan": "~1.0.0",
    "cookie-parser": "~1.0.1",
    "body-parser": "~1.0.0",
    "debug": "~0.7.4",
    "ejs": "~0.8.5"
  }
}
              </code></pre>
            </section>

            <section>
              <h2>/views/*.ejs</h2>
              <h3>example: index.ejs</h3>
              <h3>Note the &lt;%= .. %&gt; server tags</h3>
              <pre><code>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;
    &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
            </section>

            <section>
              <h2>/routes/*.js</h2>
              <h3>These are akin to controllers in MVC</h3>
              <h3>A route handler (callback) is associated with a request path</h3>
              <pre><code>
var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function(req, res) {
  res.render('index', { title: 'Express' });
});

module.exports = router;
              </code></pre>
            </section>

            <section>
              <h2>/public/stylesheets</h2>
              <h2>/public/javascripts</h2>
              <h2>/public/images</h2>
            </section>

            <section>
                <h2>Don't we need a database and models?</h2>
                <h3>Yes. We'll do that.</h3>
                <h3>But before we get into data and models, let's get familiar..</h3>
            </section>

            <section>
                <h2>Write a new view</h2>
                <h3>at /views/visits.ejs:</h3>
                <pre><code class="html">
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Page Visits&lt;/title&gt;
        &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Hi, <%= my_name %>&lt;/h1&gt;
        &lt;em&gt;we'll fill this in a minute..&lt;/em&gt;
      &lt;/body&gt;
    &lt;/html&gt;</code></pre>
                Again, note the &lt;%= .. %&gt;. This is data that will be filled in via ejs, and that data will come from our route handler.
            </section>

            <section>
                <h2>Write a route</h2>
                <h3>at /routes/visits.js:</h3>
                <pre><code class="javascript">
            var express = require('express');
            var router = express.Router();

            router.get('/', function(req, res) {
              res.render('visits', { my_name: "Tim" }); // -- find our view
            });

            module.exports = router;
                </code></pre>
                We provide data to the ejs templating engine in our render() call.
            </section>

            <section>
                <h2>Hook up requests with the route</h2>
                <h3>in app.js:</h3>
                <pre><code class="javascript">
            ...
            var routes = require('./routes/index');
            var users = require('./routes/users');
            var visits = require('./routes/visits'); // -- the route
            ...
            app.use('/', routes);
            app.use('/users', users);
            app.use('/visits', visits); // -- the request assignment
            ...
                </code></pre>
            </section>

            <section>
                <h3>restart your server and check out</h3>
                <h2>http://localhost:3000<b>/visits</b></h2>
                <img src="images/act2part2_begin2_screenshot.png" />
            </section>

            <section>
                <h3>Right, back to the database and models</h3>
            </section>

            <section>
                <h2>First, add a bit to package.json for the mongo dependency</h2>
                <pre><code class="json">
                   ...
                    "debug": "~0.7.4",
                    "ejs": "~0.8.5",
                    "mongoose": "3.8.12"
                  }
                }
                </code></pre>
                <h3>and install</h3>
                <pre><code class="bash">
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h2>Create a new folder and file, /models/visit.js</h2>
                <pre><code class="javascript">
                var mongoose = require('mongoose')
                   ,Schema = mongoose.Schema
                   ,ObjectId = Schema.ObjectId;

                var visitSchema = new Schema({
                    thread: ObjectId,
                    date: {type: Date, default: Date.now},
                    user_agent: {type: String, default: 'none'}
                });

                module.exports = mongoose.model('Visit', visitSchema);
                </code></pre>
            </section>

            <section>
                <h3>And use that model to write data to mongo in app.js</h3>
                <pre class="stretch"><code class="javascript">
...
// -- this can go near the top
var mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/myapp');
...
// -- bunch this with the other requires
var Visit = require("./models/visit.js");
...
// -- we run some code inline with each request - a new request decorator
// -- put this before the route handlers
app.use(function(req, res, next){
    new Visit({user_agent: req.headers['user-agent']}).save();
    next();
});

app.use('/', routes);
app.use('/users', users);
app.use('/visits', visits); // -- the request assignment
...
                </code></pre>
            </section>

            <section>
                <h2>careful</h2>
                <h3>Now that our app will try to talk to a database, that database will need to be running</h3>
                <pre><code class="bash">
                    # in a Mac OS X terminal
                    $ mongod --config /usr/local/etc/mongod.conf

                    # in Ubuntu
                    $ mongod --config /etc/mongodb.conf
                </code></pre>
            </section>

            <section>
                <h3>restart your server and check out</h3>
                <h2>http://localhost:3000<b>/visits</b></h2>
            </section>

            <section>
                <h2>I'm writing to a database, but I can't see my data!</h2>
                <img src="images/drwho.gif" />
                <h3>Let's fix that.</h3>
            </section>

            <section>
                <h3>Modify the route visits.js to fetch the data</h3>
                <h4>Don't forget to pass visits to your view!</h4>
                <pre class="stretch"><code class="javascript">
...
var Visit = require("../models/visit.js"); // -- new require

router.get('/', function(req, res) {

  var query = Visit.find(); // -- only creating a query object
  query.sort({date: -1}); // -- no execution here

  // -- we still have a render() call
  // -- but it is now in the callback to our database query execution
  query.exec(function(err, visits){
    // -- also note we are passing the results of our query to ejs
    res.render('visits', { my_name: "Tim", visits: visits });
  });
});
...
                </code></pre>
            </section>

            <section>
                <h2>And modify the view visits.ejs to render data</h2>
                <pre><code class="html">
            ..
            &lt;h1&gt;Hi, <% my_name %>&lt;/h1&gt;
            &lt;h2&gt;Look who's visiting your site!&lt;/h2&gt;
            &lt;% for(var v in visits){ %&gt;
              &lt;p&gt;&lt;%- visits[v].user_agent %&gt;&lt;/p&gt;
            &lt;% } %&gt;
            ..
                </code></pre>
            </section>

            <section>
                <h3>restart your server and check out</h3>
                <h2>http://localhost:3000<b>/visits</b></h2>
                (keep refreshing, you'll see it)
                <img src="images/act2part2_begin4_screenshot.png" />
            </section>

            <section>
                <h2>Socket.IO</h2>
                <h3>The final frontier</h3>
                (cue music)
            </section>

            <section>
                <h2>Firstly, what is Socket.IO?</h2>
                <h3>A Node JS module which provides bi-directional socket communication between client and server</h3>
            </section>

            <section>
                <h2>What makes it different from regular web traffic over port 80?</h2>
                <h3>Socket.IO establishes a <b style='color:00c0c0;'>persistent</b> open socket over which <b style='color:00c0c0;'>both server and client</b> can freely initiate communicate with each other</h3>
            </section>

            <section>
                <h2>What does Socket.IO have to do with Express?</h2>
                <h3>Socket.IO is its own thing, and neither Socket.IO nor Express need each other. But Socket.IO integrates with Express so easily that we just had to show it.</h3>
            </section>

            <section>
                <h2>Let's try it</h2>
                <h3>First, set up your dependency</h3>
                <pre><code class="json">
                    ...
                        "debug": "~0.7.4",
                        "ejs": "~0.8.5",
                        "mongoose": "3.8.12",
                        "socket.io": "1.0.3"
                      }
                    }
                </code></pre>
                <h3>And install</h3>
                <pre><code class="bash">
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h3>Socket.IO runs as its own server, alongside our Express app</h3>
                <p>Put this snippet near the top of app.js, after 'app' is defined.</p>
                <pre><code class="javascript">
                    var server = require('http').createServer(app);
                    var io = require('socket.io').listen(server);
                    server.listen(3001);
                </code></pre>
            </section>

            <section>
                <h3>We define "endpoints", or "namespaces" for the server, much like routes.</h3>
                <p>Here, '/chat' is the namespace.</p>
                <p>Put this snippet somewhere after 'io' is defined in app.js.</p>
                <pre><code class="javascript">
            var chat = io.of('/chat').on('connection', function(socket){
                socket.on('chat', function(data){
                    data.color = 'green';
                    socket.emit('chat', data);
                    data.color = 'red';
                    socket.broadcast.emit('chat', data);
                });
            });
                </code></pre>
            </section>

            <section>
                <h3>This is just an HTML form, which will help us interact with the server from the client</h3>
                <p>This snippet goes in index.ejs somewhere in the BODY tag..</p>
                <pre><code class="html">
        &lt;div id="chatlog" style="height: 200px;overflow-y:scroll;"&gt;&lt;/div&gt;
        &lt;textarea id="chatwindow" cols="30" rows="10"&gt;&lt;/textarea&gt;
        &lt;input id="send_chat" type="submit" value="Send" /&gt;
                </code></pre>
            </section>

            <section>
                <h3>Also in index.ejs in the HEAD tag we'll put our client-side javascript, which connects to, reacts to, and sends messages to the server</h3>

                <pre class="stretch"><code class="html">
    &lt;script src="http://localhost:3001/socket.io/socket.io.js"&gt;&lt;/script&gt;
    &lt;script src="//code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;

        var chat_socket = io.connect('http://localhost:3001/chat');

        chat_socket.on('chat', function(data){
            $("#chatlog")
                .append(
                    $("&lt;p style='color:" + data.color + ";'&gt;&lt;/p&gt;")
                        .text(data.isay)
                );
        });
        $(document).on('click', "#send_chat", function(e){
            chat_socket.emit('chat', {isay: $("#chatwindow").val()});
            $("#chatwindow").val("");
        });
    &lt;/script&gt;
                </code></pre>
            </section>

            <section>
                <h3>restart your server and check out</h3>
                <h2>http://localhost:3000</h2>
                <h3>Try opening a few browser windows!</h3>
                <div class="stretch">
                    <div class="column" style="float: left;margin: 0;width: 50%;">
                      <img src="images/act2part2_begin5_screenshota.png" />
                    </div>
                    <div class="column" style="float: left;margin: 0;width: 50%;">
                      <img src="images/act2part2_begin5_screenshotb.png" />
                    </div>
                </div>
            </section>

            <!-- Act 3: Meteor.js and Reactive Apps -->
            <section>
                <h1>Act 3</h1>
                <h2>Meteor</h2>
            </section>

            <section>
                <h1>Meteor</h1>
                <h3>A web app framework for real-time, reactive apps</h3>
                <h3>* powered by Node.js</h3>
            </section>
            <section>
                <h1>Real-time</h1>
                <h3>Server pushes data to all clients, immediately</h3>
            </section>
            <section>
                <h1>Reactive</h1>
                <h3>Changes on any client are immediately pushed to all other clients</h3>
            </section>
            <section>
                <h1>Slick, huh?</h1>
            </section>
            <section>
                <h2>Meteor is designed for single page apps</h2><br>
                So, no routing or multiple views out of the box
                <br><br>
                (Though you can add these features with packages)
            </section>
            <section>
                <h2>Let's check it out</h2>
                <br>
                <h3>We're going to make an interactive, real-time map</h3>
            </section>
            <section>
                <h2>Install Meteor, and create a new dir</h2>
                <pre><code class="bash">
                $ npm install meteor -g
                $ mkdir node-act3
                $ cd node-act3
                </code></pre>
            </section>
            <section>
                <h2>Meteor has a generator, too!</h2>
                <br>
                <h4>Generate your app</h4>
                <pre><code class="bash">
                $ meteor create mapit
                $ cd mapit
                $ meteor
                [[[[[ ~/Dropbox/Code/test/mapit ]]]]]

                => Started proxy.
                => Started MongoDB.
                => Started your app.

                => App running at: http://localhost:3000/
                </code></pre>
                <br>
                <h4>Run "meteor --help" if you want to see behind the curtain</h4>
            </section>
            <section>
                <img src="images/mapit-hello.png">
            </section>
            <section>
                <h2>You'll notice that meteor claims it has started MongoDB</h2>
                <br>
                <h4>...even if you don't have MongoDB installed...</h4>
            </section>
            <section>
                <h1>That's because </h1><h1>Meteor is a liar!</h1>
            </section>
            <section>
                <h2>Just kidding!</h2>
                <br>
                <h3>It's really because meteor has installed its own</h3><h3> embedded instance of Mongodb</h3>
                <br>
                <h3>You can access it anytime using:</h3>
                <pre><code class="bash">
                $ meteor mongo
                </code></pre>
            </section>
            <section>
                <h2>Autopublish</h2>
                <p>By default, Meteor publishes all collections to client automatically. </p>
                <br>
                <p>This is basically a security nightmare, and can also bog down your app if you have lots of data. Let's disable it:
                <pre><code class="bash">
                $ meteor remove autopublish
                autopublish: removed
                </code></pre>
                <br>
                Note: this means we will have to specify collections to be published and subscribed to. It's for the best.
            </section>
            <section>
                <h2>Now let's check out the generated code</h2>
            </section>
            <section>
                <h2>Meteor uses 3 default files:</h2>
                <ul>
                    <li>mapit.js -- client/server javascript</li>
                    <li>mapit.html -- client template/view</li>
                    <li>mapit.css -- stylez</li>
                </ul>
            </section>
            <section>
                <h3>mapit.js</h3>
                <pre class="stretch"><code class="javascript">
                    if (Meteor.isClient) {
                      Template.hello.greeting = function () {
                        return "Welcome to mapit.";
                      };

                      Template.hello.events({
                        'click input': function () {
                          // template data, if any, is available in 'this'
                          if (typeof console !== 'undefined')
                            console.log("You pressed the button");
                        }
                      });
                    }

                    if (Meteor.isServer) {
                      Meteor.startup(function () {
                        // code to run on server at startup
                      });
                    }

                </code></pre>
            </section>
            <section>
                <h2>You'll see two sections in the mapit.js file:</h2>
                <pre><code class="javascript">
                    if (Meteor.isClient) {
                        ...
                    }
                    if (Meteor.isServer) {
                        ...
                    }
                </code></pre>
            </section>
            <section>
                <h3>Any code outside these sections is <em>shared</em> between client and server</h3>
                <br>
                <h3>That's the beauty of an all-JavaScript app</h3>
            </section>
            <section>
                <h3>mapit.html</h3>
                <pre><code class="html">
                    &lt;head>
                      <title>mapit</title>
                    &lt;/head>

                    &lt;body>
                      {{> hello}}
                    &lt;/body>

                    <template name="hello">
                      <h1>Hello World!</h1>
                      {{greeting}}
                      <input type="button" value="Click" />
                    </template>
                </code></pre>
            </section>
            <section>
                <h3>Templates</h3>
                Meteor uses a slightly modified version of Handlebars templates (called Spacebars)
                <pre><code class="html">
                    ..
                    &lt;body>
                        <div>
                            {{> mytemplate}}
                        </div>
                    &lt;/body>
                    ..
                    <template name="mytemplate">
                        <div>
                            <b>{{someValue}}</b>
                        </div>
                    </template>
                </code></pre>
                Inside the template, you can access data from the server-side
                But in Meteor, this data will update <em><b>reactively</b></em>
            </section>
            <section>
                <h3>I don't see any callbacks, and that makes me</h3><h3> uncomfortable</h3>
                <img src="images/uncomfortable.gif">
            </section>
            <section>
                <h2>Fibers</h2>
                <br>
                <h3>Meteor uses a node.js library called <em>fibers</em>,</h3>
                <h3>which allows sequential execution of async functions, without callbacks</h3>
            </section>
            <section>
                <h2>We don't have time to go into how fibers works, but it's pretty cool</h2>
                <br>
                <h3>If you want to learn more: </h3>
                <a href="http://howtonode.org/generators-vs-fibers">http://howtonode.org/generators-vs-fibers</a>
                <a href="http://meteorhacks.com/fibers-eventloop-and-meteor.html">http://meteorhacks.com/fibers-eventloop-and-meteor.html</a>

            </section>
            <section>
                <h2>This means meteor apps are straightforward to program</h2>
                <br>
                <h3>At the cost of some "framework magic"</h3>
            </section>
            <section>
                <h2>Let's replace that generated code with something better</h2>
            </section>
            <section>
                <h2>Collections</h2>
                <h4>Meteor stores data as JSON objects in MongoDB collections</h4>
                <img src="./images/mongo_collections.png" width="80%"></img>
            </section>
            <section>
                <h2>Now let's create a reactive collection</h2>
            </section>
            <section>
                <h4>mapit.js</h4>
                <pre class="stretch"><code class="javascript">
            Markers = new Meteor.Collection('markers');

            if (Meteor.isClient) {
                Meteor.subscribe("markers");

                Template.markerlist.markers = function() {
                    return Markers.find({});
                };
            }
            if (Meteor.isServer) {
                // Insert a marker if none exist
                if(Markers.find().count() == 0) {
                    console.log("No markers found in collection - inserting one");
                    Markers.insert({"coords": [49.25044, -123.137]});
                }

                // publish collection to client
                Meteor.publish("markers", function () {
                    // you can specify constraints in find() query, if desired
                    return Markers.find();
                });
            }
                </code></pre>
                This 'marker' collection will later put points on our map
            </section>
            <section>
                <h3>Now visualize the collection</h3>
                <h4>mapit.html</h4>
                <pre class="stretch"><code class="html">
            &lt;head>
              <title>mapit</title>
            &lt;/head>
            &lt;body>
                <div>
                    {{> markerlist}}
                </div>
            &lt;/body>

            <template name="markerlist">
              {{#each markers}}
                <div>
                  <b>Marker</b><br>
                  <span>-- Coordinates: {{coords}}</span><br>
                </div><br>
              {{/each}}
            </template>

                </code></pre>
            </section>

            <section>
                <h2>Forget about HTTP POSTS or AJAX</h2>
                <br>
                <h3>With Meteor you don't need them. Meteor handles all data synchronization between client and server</h3>
                <br>
                <h3>Collections are accessed as reactive streams of data</h3>
            </section>


            <section>
                <h3>Let's try it with our marker collection</h3>
                <br>
                Open up two browser tabs/windows, and go to your app
            </section>
            <section>
                <img class="stretch" src="images/2-screens.png"/>
            </section>
            <section>
                <h3>The Test</h3>
                <p>Since the <em>Marker</em> collection is shared between client and server, we can access it from client-side debug tools.</p>
                <br>
                Pull up your debug console on one tab, and add another marker:
                <pre><code class="javascript">
            > Markers.insert({"coords": [48, -123]});
                </code></pre>

                <p>You'll see this marker appear in the list of both clients</p>

            </section>
            <section>
                <h1>Part 2</h1>
<br>
    If your code has errors, start with the files from directory
    <b><p> /act-3-meteor-realtime-webapps/begin-part-2/ </p></b>
            </section>
            <section>
                <h1>Map!</h1>
                <br><br>
                <h3>Now add the interactive map</h3>
                <p>We're going to use Leaflet.js. Since Meteor is a highly customized framework, adding a standard JavaScript library may be a bit tricky...</p>
            </section>
            <section>
                <h2>Luckily, there's Meteorite</h2>
                <br>
                <p>Meteorite is a package manager for Meteor, similar to NPM</p>
                <br><p>Go ahead and install the meteorite client:</p>
                <pre><code class="bash">
                $ npm install -g meteorite
                </code></pre>
                <br>
                <p>You can search Meteorite packages at [PUT LINK HERE]</p>
            </section>
            <section>
                <h2>Install Leaflet.js</h2>
                <br>
                <p>Since there is already a Meteorite package for Leaflet, this becomes very easy:
                <pre><code class="bash">
                $ mrt add leaflet
                </code></pre>
            </section>
            <section>
                <h2>Make a template for the map control, and add it to the view</h2>
            </section>
            <section>
                <p>Add the following to the client section of mapit.js:</p>
                <pre class="stretch"><code class="javascript">
Template.map.rendered = function() {
    L.Icon.Default.imagePath = 'packages/leaflet/images';

    // initialize Leaflet map object
    window.map = L.map('map', {
      doubleClickZoom: false,
      zoomControl:false
    }).setView([45.52854352208366,-122.66302943229674], 13);

    L.tileLayer.provider('Thunderforest.Outdoors').addTo(map);

    var markers = Markers.find(); // db cursor Markers

    // Watch the Markers collection for 'add' action
    markers.observe({
        // When a new marker is added collection, add it to the map
        added: function(marker) {
            L.marker(marker.coords).addTo(map);
        }
    });
}
                </code></pre>
            </section>
            <section>
                <p>Update mapit.html:</p>
                <pre class="stretch"><code class="html">
&lt;head>
  <title>mapit</title>
&lt;/head>
&lt;body>
    <div>
      <div style="width: 75%; margin: 10px; float: left">
        {{> map}}
      </div>
      <div style="width: 20%; float: right; margin-top:90px;">
        {{> markerlist}}
      </div>
    </div>
&lt;/body>

&lt;template name="map">
    <div id="container">
      <h1 class="title">Mapit!</h1>
      <div id="map" class="map"></div>
    </div>
&lt;/template>
...
                </code></pre>
            </section>

            <section>
                <h3>And a little CSS</h3>
                <br>
                <p> mapit.css</p>
                <pre><code>
    #map {
      height: 700px;
      margin: 0 auto;
    }
                </code></pre>
            </section>

            <section>
                <img src="images/map1.png"/>
            </section>

            <section>
                <h3>Now any time a marker is added, it will appear on the map</h3>
                <br>
                <p>Next, add a double-click handler to the map template, so we can add markers through the UI.</p>
                <br>
                <p> Edit the Template.map.rendered function in mapit.js to add this feature:</p>
                <pre><code class="javascript">
        ..
        // assign click event to add markers
        window.map.on('dblclick', function(event, object) {
            // We're storing the marker coordinates in an extensibel JSON
            // data structure, to leave room to add more info later
            console.log("inserting marker: " + event.latlng);
            Markers.insert({"coords": [event.latlng.lat,event.latlng.lng]});
        });
        ..
                </code></pre>
            </section>
            <section>
                <h2>Try it out!</h2>
                <br><br>
                <h3>Double-clicks should add markers reactively, meaning all clients will see them immediately</h3>
            </section>
            <section>
                <h1>Part 3</h1>
<br>
    If your code has errors, start with the files from directory
    <b><p> /act-3-meteor-realtime-webapps/begin-part-3/ </p></b>
            </section>
            <section>
                <h2>Users</h2>
                <p>Let's add one last feature - Users</p>
            </section>
            <section>
                <h2>Meteor Packages</h2>
                <br><br>
                <p>You've seen Meteorite packages, but Meteor has its own subset of packages included, including packages for built-in user auth</p>
                <br>
                <p>Add user auth funcitonality this way:</p>
                <pre><code class="bash">
                $ meteor add accounts-password
                $ meteor add accounts-ui
                </code></pre>
            </section>
            <section>
                <h3>Now for a lot of work to enable user auth:</h3>
                <p>Update mapit.html:</p>
                <pre class="stretch"><code class="html">
    &lt;body>
        <!--BOOM. Free authentication. -->
        <div>
          {{> loginButtons}}
        </div>

        <div>
          <div style="width: 75%; margin: 10px; float: left">
            {{> map}}
          </div>
          <div style="width: 20%; float: right; margin-top:90px;">
            {{> markerlist}}
          </div>
        </div>
    &lt;/body>
    ...
                </code></pre>
            </section>
            <section>
                <img src="images/meteor-signin.png">
            </section>
            <section>
                <img src="images/meteor-auth.png">
            </section>
            <section>
                <img src="images/meteor-loggedin.png">
                <p>You can get the current user with Meteor.user(), or their userid by Meteor.userId()</p>
            </section>
            <section>
                <h3>Now we can record the user who created a marker</h3>
                <p>Make the following changes:</p>
                <br>
                <p>mapit.js -- window.map.on('dblclick'...)</p>
                <pre><code class="javascript">
    window.map.on('dblclick', function(event, object) {
        // We're storing the marker coordinates in an extensibel JSON
        // data structure, to leave room to add more info later
        console.log("inserting marker: " + event.latlng);

        // ADDED
        // check for user, override if no one is logged in
        var username;
        if(Meteor.user()) username = Meteor.user().emails[0].address;
        else username = "anonymous";

        Markers.insert({"coords": [event.latlng.lat,event.latlng.lng],
                        "user": username }); // CHANGED
    });
                </code></pre>

            </section>

            <section>
                <p>mapit.js -- markers.observe()</p>
                <pre><code class="javascript">
        markers.observe({
            // When a new marker is added collection, add it to the map
            added: function(marker) {
                // CHANGE
                L.marker(marker.coords).addTo(map).bindPopup(marker.user);
            }
        });
                </code></pre>
                <p>mapit.html -- markerlist template</p>
                <pre><code class="html">
    <template name="markerlist">
      {{#each markers}}
        <div>
          <b>Marker</b><br>
          <span>-- Coordinates: {{coords}}</span><br>
          <span>-- User: {{user}}</span><br> <!-- ADD ME! -->
        </div><br>
      {{/each}}
    </template>
                </code></pre>
            </section>

            <section>
                <img class="stretch" src="images/act3-final.png"/>
            </section>

            <section>
                <p>And so, we leave you to boldly go, and</p>
                <img class="stretch" src="images/picard.jpg"/>
            </section>
            <section>
                <h2>Thank you!</h2>
                <br>
                <div>
                    <p>All code and slides from this workshop can be found at:</p>
                    <a href="https://github.com/cacois/nodejs-three-ways">https://github.com/cacois/nodejs-three-ways</a>
                </div>
                <br>
                <br>

                <div>
                    <div class="column" style="float: left;margin: 0;width: 50%;">
                        <p style="text-align: left;margin-left: 0;">Aaron = </p>
                        <p style="text-align: left;margin-left: 0;">{</p>
                        <p style="text-align: left;margin-left: 30;">twitter: <a href="https://twitter.com/aaroncois">@aaroncois</a>,</p>
                        <p style="text-align: left;margin-left: 30;">blog: <a href="www.codehenge.net">www.codehenge.net</a>,</p>
                        <p style="text-align: left;margin-left: 30;">github: <a href="http://github.com/cacois">github.com/cacois </a></p>
                        <p style="text-align: left;margin-left: 0;">}</p>
                    </div>
                    <div class="column" style="float: left;margin: 0;width: 50%;">
                        <p style="text-align: left;margin-left: 0;">Tim =</p>
                        <p style="text-align: left;margin-left: 0;">{</p>
                        <p style="text-align: left;margin-left: 30;">twitter: <a href="https://twitter.com/timpalko">@timpalko</a>,</p>
                        <p style="text-align: left;margin-left: 30;">github: <a href="http://github.com/tpalko">github.com/tpalko </a></p>
                        <p style="text-align: left;margin-left: 0;">}</p>
                    </div>
                </div>

            </section>

        </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
        // Required, even if empty.
        Reveal.initialize({
            controls: true,
  		    progress: true,
  			history: true,
  			center: true,
            slideNumber: true,

			theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
			transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

			// Parallax scrolling
			// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
			// parallaxBackgroundSize: '2100px 900px',

			// Optional libraries used to extend on reveal.js
			dependencies: [
				{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
				{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
			]
        });
    </script>
</body>
</html>
