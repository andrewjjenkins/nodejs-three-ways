<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Reveal.js 3 Slide Demo</title>
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <!--Add support for earlier versions of Internet Explorer -->
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
    <!-- Wrap the entire slide show in a div using the "reveal" class. -->
    <div class="reveal">
        <!-- Wrap all slides in a single "slides" class -->
        <div class="slides">

            <!-- Introduction -->
            <section>
                <h1>Node.js Three Ways</h1>
                <h2>A Tutorial in Three Acts</h2>
                <p>Constantine Aaron Cois and Tim Palko</p>
                <p>Carnegie Mellon University, Software Engineering Institute</p>
            </section>

            <section>
                <h2>Aaron === @aaroncois</h2>
                <h3><a href="http://www.codehenge.net">www.codehenge.net</a></h3>
                <h3><a href="http://github.com/cacois/">http://github.com/cacois/</a></h3>
                <br><br>
                <h2>Tim === Tim</h2>
            </section>
            <section>
                <h2>Code</h2>
                <b>Working code</b> from this workshop can be found on github:
                <br><br>
                <h3><a href="https://github.com/cacois/nodejs-three-ways">https://github.com/cacois/nodejs-three-ways</a></h3>
                <br><br>
                <h2>Slides</h2>
                You can also find these slides here:
                <br><br>
                <h3><a href="http://cacois.github.io/nodejs-three-ways/#/">http://cacois.github.io/nodejs-three-ways/#/</a></h3>
            </section>

            <section id="slide2">
                <h1>Node.js!</h1>
                <p>What's the big deal?</p>
            </section>

            <section>
                <h2>Cool things that Node is</h2>
                    <ul>
                      <li> JavaScript</li>
                      <li> Server-side</li>
                      <li> Event-driven</li>
                      <li> <em>Fast</em> and <em>Efficient</em></li>
                    </ul>
            </section>

            <section>
              <h2>JavaScript</h2>
              <br>
              <h3>This means you can...</h3>
              <br>
              <img src="./images/write_all_the_code_in_javascript1.jpg"></img>
            </section>

            <section>
              <h1>Advantages to JS</h1>
              <br><ul>
                  <li>Familiar</li>
                  <li>Low barrier to entry</li>
                  <li>Team Redundancy</li>
              </ul><br>
             <p>(Front-end devs and back-end devs speak the same language)</p>
            </section>

            <section>
              <h2>Let's talk <em>speed</em></h2>
              <br>
              <h3>Node.js was designed for highly-concurrent network applications</h3>
              <h4>(Read: scalable web apps, among other things)</h4>
            </section>

            <section data-background="./images/v8-logo.png"  data-background-size="80%">
              <h1 style="color:black">Fast</h1>
              <br>
              <br>
              <h3 style="color:black">Node uses the V8 JavaScript engine powering Google Chrome</h3><br>
              <h3 style="color:black">This means lightning fast JavaScript execution</h3>
            </section>

            <section>
              <h1>Efficient</h1>
              <h2>Node.js is <em>asynchronous</em> and <em>event-driven</em></h2>
              <br>
              <p>This means you have to think a bit differently</p>
            </section>

            <section data-background="./images/event-loop-1.png" data-background-size="70%"/>
            </section>

            <section data-background="./images/event-loop-2.png"  data-background-size="70%"/>
            </section>

            <section data-background="./images/event-loop-3.png"  data-background-size="70%"/>
            </section>

            <section>
              <h1>Callbacks</h1>
              <pre><code>
                fs = require('fs');
 
                fs.readFile('f1.txt','utf8',function(err,data){
                  if (err) {
                    // handle error
                  }
                  console.log(data);
                });
              </code></pre>
            </section>

            <section>
              <h1>Callbacks</h1>
              <h3>Equivalent Syntax </h3>
              <pre><code data-trim>
                fs = require('fs');
 
                fs.readFile('f1.txt','utf8',

                  function(err,data) {
                    if (err) {
                      // handle error
                    }
                    console.log(data);
                  }

                );
              </code></pre>
            </section>
            <section>
              <h2>Let's get to work</h2>
            </section>

            <!-- Act 1: Node.js Network Services -->
            <section>
                <h1>Act 1</h1>
                <h2>Node.js Network Services</h2>
            </section>

            <section>
                <h2>We're going to build a scalable, real-time notification service</h2>
            </section>
            <section>
              <h2>Here's what it will look like</h2>
              <img src="./images/notification-system.png" />
            </section>
            <section>
                <h2>Make sure you have Node.js installed</h2>
                <br>
                <p>http://www.nodejs.org</p>
                <br>
                <h2>And Redis</h2>
                <br>
                <pre><code>
    $ wget http://download.redis.io/releases/redis-2.8.12.tar.gz
    $ tar xzf redis-2.8.12.tar.gz && cd redis-2.8.12
    $ make
                </code></pre>
                <p>You should see the server startup in stand alone mode with:</p>
                <pre><code>
    $ redis-server
                </code></pre>
            </section>
            <section>
                <h2>Create a project directory and code file</h2>
                <pre><code data-trim>
                  $ mkdir node-act1
                  $ cd node-act1
                  $ touch worker.js
                </code></pre>

                worker.js will be our asynchronous notification worker
            </section>

            <section>
                <h2>A first test</h2>

                Put the following in worker.js:
                <pre><code data-trim>
                  console.log("Hello OSCON!");
                </code></pre>

                ...and run it:
                <pre><code data-trim>
                  $ node worker.js
                </code></pre>
            </section>

            <section>
              <h2>Node Package Manager (NPM)</h2>
              <br>
              We will need to use some external packages for our app.
              <br><br>
              Specifically, we will need the Redis client package. Install it using:
              <pre><code>
                $ npm install redis
              </code></pre>
              The package will be installed in a local node_modules directory. Check it out:
              <pre><code>
                $ ls node_modules
              </code></pre>
            </section>

            <section>
                Now we can start by connecting to Redis to receive Pub/Sub messages
                <br><br>
                Add the following to worker.js:
                <pre><code data-trim>
              // import the redis module
              var redis = require("redis");

              // create a redis client object
              var pubSubClient = redis.createClient('6379', 'localhost');

              // subscribe to 'notifications' collection
              pubsubClient.subscribe("notifications");

              // define message handler
              pubsubClient.on("message", function(channel, message) {
                  console.log('Received a message: ' + message);
              });
                </code></pre>
                ...and run it:
                <pre><code data-trim>
                  $ node worker.js
                </code></pre>
            </section>

            <section>
                Now let's test. Write to the collecion in Redis:
                <pre><code data-trim>
              $ redis-cli

              redis-cli> publish notifications '{"identifier": 1, "message": "Huzzah!"}'
                </code></pre>
            </section>

            <section>
                Received a message: Huzzah!
                <br>
               <img src=./images/futurama-huzzah.jpg />
            </section>

            <section>
              Now let's take a step back and set up some basic stuff for our project
            </section>

            <section>
                <h2>Config File</h2>
                <br>
                My favorite config pattern Node is to create a module to store my config
                <br><br>
                Create a file:
                <pre><code data-trim>
                  $ touch config.js
                </code></pre>
                .. and put the following content in it:
                <pre><code data-trim>
                module.exports = {
                  host: 'localhost',
                  port: 6379
                }
                </code></pre>
                The 'module.exports' value indicates what will be returned from a require(...) call to this file
            </section>

            <section>
              Now import the file into your worker.js app by adding the following to the top of the file:
              <pre><code data-trim>
            var config = require("./config.js")
              </code></pre>
              Now we can replace the Redis client instantiation:
              <pre><code data-trim>
            var pubSubClient = redis.createClient('6379', 'localhost');
              </code></pre>
              with:
              <pre><code data-trim>
            var pubSubClient = redis.createClient(config.port, config.host);
              </code></pre>
              <br>
              Nifty!
            </section>

            <section>
              <h2>Package Management</h2>
              We've already seen how to install individual packages using NPM
              <br><br>
              But can we automate this, and centrally manage package requirements?
              <br><br>
              Yes, with a package.json file:
              <pre><code data-trim>
            $ touch package.json
              </code></pre>
            </section>

            <section>
              <h2>Package.json</h2>
              A lot of info can go into a package.json file
              <br><br>
              We'll only use a small bit of its functionality here. Write this:
              <pre><code data-trim>
            {
              "name": "act-1-network-services",
              "author": "MY NAME <my@email.com>",
              "version": "1.0.0",
              "dependencies": {
                "redis": "*",
                "nodemailer": "*"
              },
              "engine": { "node" : ">=0.10.0" }
            }
              </code></pre>
              <p>This specifies:</p>
              <ul>
                <li>some metadata about the app</li>
                <li>a list of package dependencies (we'll need nodemailer later)</li>
                <li>a required Node version</li>
              </ul>

            </section>
            <section>
              <h2>NPM Install</h2>
              Now that we have a package.json, we can install the app and its dependencies in one command:
              <pre><code data-trim>
            $ npm install
              </code></pre>
              <p>NPM will look for a local package.json and use it to set everything up</p>
            </section>

            <section>
                <h2>Now back to the action...</h2>
                <br>
                <h3>worker.js should look like this:</h2>
                <pre><code data-trim>
              // import the redis module
              var redis = require("redis");

              // read in the config file as a JavaScript object
              var config = require("./config.js");

              // create a redis client object
              var pubSubClient = redis.createClient('6379', 'localhost');

              // subscribe to 'notifications' collection
              pubsubClient.subscribe("notifications");

              // define message handler
              pubsubClient.on("message", function(channel, message) {
                  console.log('Received a message: ' + message);
              });
                </code></pre>
            </section>

            <section>
                Let's make that message handler function a bit more manageable
                <br><br>
                Move the closure out to a separtely defined function:
                <pre><code data-trim>
            // define message handler
            pubsubClient.on("message", handleMessage);

            function handleMessage(channel, message) {
                console.log('Received a message: ' + message);
            }
                </code></pre>
            </section>

            <section>
                Now let's make it do something more interesting.
                <br><br>
                We want multiple, fault-tolerant workers to handle notifications. This will make our system scalable.
                <br><br>
                We can accomplish this by making all workers race to handle any notification dispatched - which means <em>locks</em>
                <pre><code data-trim>
            // define message handler
            pubsubClient.on("message", handleMessage);

            function handleMessage(channel, message) {
                console.log('Received a message: ' + message);

                var payload = JSON.parse(message);

                acquireLock(payload, 1, lockCallback);
            }
                </code></pre>

            Notice that we've identified two functions we need to write: <b>acquireLock</b> and the callback <b>lockCallback</b>
            </section>

            <section>
                <h2>acquireLock</h2>
                We can use Redis for locks, too. The first worker to write a lock for a given notification wins!
                <pre><code data-trim>
    function acquireLock(payload, attempt, callback) {
        // create a lock id string
        var lockIdentifier = "lock." + payload.identifier;

        console.log("Trying to obtain lock: %s", lockIdentifier);

        client.setnx(lockIdentifier, "Worker Name", function(error, success) {
            if (error) {
                logger.error("Error acquiring lock for: %s", lockIdentifier);
                return callback(error, dataForCallback(false));
            }

            var data = {
                "acquired" : success,
                "lockIdentifier" : lockIdentifier,
                "payload" : payload
            };
            return callback(data);
        });
    }
                </code></pre>
                Give your worker a better name than "Worker Name"!
                <br><br>(Protip: If you want to pass a worker name/id in from the command line, check out the <b>process.argv</b> object)
            </section>

            <section>
                <h2>lockCallback</h2>
                Now we need a callback after the worker attempts to acquire a lock.
                <br><br><p>This function needs to handle success or failure by a given worker.</p>
                <pre><code>
    function lockCallback(data) {
        if(data.acquired == true) {
            console.log("I got the lock!");

            // send notification!
            // TODO: actually notify
            console.log('I win! Sending notification: %s',
                         JSON.stringify(data));
        }
        else console.log("No lock for me :(");
    }
                </code></pre>
            </section>

            <section>
                We've written a lot of code - let's test
                <br><br>
                <pre><code>
$ node worker.js
$ redis-cli

redis-cli> publish notifications '{"identifier": 2, "message": "in a bottle"}'

    // this next command will show you the keys currently in
    // redis. You should see "lock.2"

redis-cli> keys *

    // this command will show the value for the key "lock.2". This
    // will be the name of the worker who won the lock

redis-cli> get "lock.2"
                </code></pre>

            </section>

            <section>
                <h2>Let's scale</h2>
                <br>
                Fire up multiple workers (be sure to give them different names), and watch them race!
            </section>

            <section>
                <h2>Final Step</h2>
                Call a function to send a notification...
                <pre><code>
    function lockCallback(data) {
        if(data.acquired == true) {
            console.log("I got the lock!");

            // send notification!
            sendMessage(data);
        }
        else console.log("No lock for me :(");
    }
                </code></pre>
            </section>
            <section>
                <h2>Final Step</h2>
                ...and send some SMTP
                <pre><code>
function sendMessage(payload) {
    console.log("Sending email notification...");
    var smtpTransport = mailer.createTransport("SMTP",{
        service: "Gmail",
        auth: {
            user: "&ltGoogle username>",
            pass: "&ltyour Google application-specific password>"
        }
    });

    var mailOptions = {
        from: "&ltemail>", // sender address
        to: "&ltemail>", // list of receivers
        subject: "Notification from Node.js", // Subject line
        text: "You are hereby notified!", // plaintext body
        html: "<b>You are hereby notified!</b>" // html body
    };

    smtpTransport.sendMail(mailOptions, function(error, response){
        if(error) console.log("Error sending mail: " + error);
        else console.log("Message sent: " + response.message);

        smtpTransport.close(); // shut down the connection pool, no more messages
    });
}
                </code></pre>
            </section>

            <!-- Act 2: Part 1: Basic Express -->

            <section>
                <h1>Act 2</h1>
                <h2>Part 1</h2>
                <h3>Basic Express</h3>
            </section>

            <section>
                <h2>Express</h2>
                <h3>A lightweight web framework for Node.js</h3>
            </section>

            <section>
                <h2>three files, 17 lines of code</h2>
                <h3>app.js, package.json, README.md</h3>
            </section>

            <section>
                <h2>Step 1: Create package.json:</h2>
                <pre><code data-trim>
                    {
                      "name": "Express Basic Tutorial",
                      "description": "I'm learning nodejs express!",
                      "version": "0.0.1",
                      "private": true,
                      "dependencies": {
                        "express": "4.4.0"
                      }
                    }
                </code></pre>

                <h3>Hint</h3> To find the latest available version of a module
                <pre><code data-trim>
                    $ npm info express version
                </code></pre>
                Or you can simply say
                <pre><code data-trim>
                    "express": "*"
                </code></pre>
            </section>

            <section>
                <h2>Step 2: Create README.md</h2>
                <pre><code data-trim>
                    # Meet My App
                    App, audience. Audience, app.
                </code></pre>
                (this file needs something in it for Express to be happy)
            </section>

            <section>
                <h2>Step 3: <strike>Profit</strike> Create app.js</h2>
                <pre><code data-trim>
                    var express = require('express');
                    var app = express();

                    app.get('/', function(req,res){
                        res.send("hi there");
                    });

                    var server = app.listen(4000, function(){
                        console.log("Listening on 4000");
                    });
                </code></pre>
            </section>

            <section>
                <h2>Step 4: Install your dependencies</h2>
                <pre><code data-trim>
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h2>Step 5: Run it</h2>
                <pre><code data-trim>
                    $ node app.js
                </code></pre>
                <h4>and visit</h4>
                <h2>http://localhost:4000</h2>
            </section>

            <section>
                <h2>That was easy..</h2>
            </section>

            <section>
                <h1>Act 2</h1>
                <h2>Part 2</h2>
                <h3>Advanced Express</h3>
                (ooooooooh...)
            </section>

            <section>
                <h2>Surely, Express can do more</h2>
                <h3>Yes, it can. And with a little help.</h3>
                (and don't call me Shirley)
            </section>

            <section>
                <h2>Express Generator</h2>
                <pre><code data-trim>
                $ npm install -g express-generator
                $ express -e ejs myapp
                $ npm install
                $ npm start
                </code></pre>
                <h3>Please</h3>
                <h4>Run "express --help" to see what options are available and grok what you're running</h4>
                <h3>and visit</h3>
                <h2>http://localhost:3000</h2>
            </section>

            <section>
                <h2>visite du code</h2>
            </section>

            <section>
                <h2>Don't we need a database, and controllers, and models?</h2>
                <h3>Yes. Let's do that.</h3>
                <h4>Actually, routes are "controllers", so one down and two to go.</h4>
            </section>

            <section>
                <h2>Before we get into data and models</h2>
                <h3>Let's get familiar</h3>
            </section>

            <section>
                <h2>Write a view</h2>
                <h3>at /views/visits.ejs:</h3>
                <pre><code data-trim>
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Page Visits&lt;/title&gt;
        &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Hi, {% my_name %}&lt;/h1&gt;
        &lt;em&gt;we'll fill this in a minute..&lt;/em&gt;
      &lt;/body&gt;
    &lt;/html&gt;</code></pre>
                Note the {% .. %}. This is data that will be filled in via ejs, and that data will come from our route handler.
            </section>

            <section>
                <h2>Write a route</h2>
                <h3>at /routes/visits.js:</h3>
                <pre><code data-trim>
            var express = require('express');
            var router = express.Router();

            router.get('/', function(req, res) {
              res.render('visits', { my_name: "Tim" }); // -- find our view
            });

            module.exports = router;
                </code></pre>
                We provide data to the ejs templating engine in our render() call.
            </section>

            <section>
                <h2>Hook up requests with the route</h2>
                <h3>in app.js:</h3>
                <pre><code data-trim>
            ...
            var routes = require('./routes/index');
            var users = require('./routes/users');
            var visits = require('./routes/visits'); // -- the route
            ...
            app.use('/', routes);
            app.use('/users', users);
            app.use('/visits', visits); // -- the request assignment
            ...
                </code></pre>
            </section>

            <section>
                <h3>again, let us visit</h3>
                <h2>http://localhost:3000<b>/visits</b></h2>
            </section>

            <section>
                <h2>Right, back to the database and models</h2>
            </section>

            <section>
                <h2>First, add a bit to package.json for the mongo dependency</h2>
                <pre><code data-trim>
                   ...
                    "debug": "~0.7.4",
                    "ejs": "~0.8.5",
                    "mongoose": "3.8.12"
                  }
                }
                </code></pre>
                <h3>and install</h3>
                <pre><code data-trim>
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h2>a model, visit.js, in /models</h2>
                <pre><code data-trim>
                var mongoose = require('mongoose')
                   ,Schema = mongoose.Schema
                   ,ObjectId = Schema.ObjectId;

                var visitSchema = new Schema({
                    thread: ObjectId,
                    date: {type: Date, default: Date.now},
                    user_agent: {type: String, default: 'none'}
                });

                module.exports = mongoose.model('Visit', visitSchema);
                </code></pre>
            </section>

            <section>
                <h2>using that model to write data to mongo in app.js</h2>
                <pre><code data-trim>
            var mongoose = require('mongoose');
            mongoose.connect('mongodb://localhost/myapp');

            var Visit = require("./models/visit.js");

            // -- we run some code inline with each request
            app.use(function(req, res, next){
                new Visit({user_agent: req.headers['user-agent']}).save();
                next();
            });
                </code></pre>
            </section>

            <section>
                <h2>careful</h2>
                <h3>Now that our app will try to talk to a database, that database will need to be running</h3>
                <pre><code data-trim>
                    $ mongod --config /usr/local/etc/mongod.conf
                </code></pre>
            </section>

            <section>
                <h2>I'm writing to a database, but I can't see my data!</h2>
                <h3>Let's fix that.</h3>
            </section>

            <section>
                <h2>Modify the route to fetch the data</h2>
                <pre><code data-trim>
            ..
            var Visit = require("../models/visit.js");

            router.get('/', function(req, res) {

              var query = Visit.find();
              query.sort({date: -1});

              query.exec(function(err, visits){
                res.render('visits', { my_name: "Tim", visits: visits });
              });
            });
            ..
                </code></pre>
            </section>

            <section>
                <h2>And modify the view to render it</h2>
                <pre><code data-trim>
            ..
            &lt;h1&gt;Hi, {% my_name %}&lt;/h1&gt;
            &lt;% for(var v in visits){ %&gt;
              &lt;p&gt;&lt;%- visits[v] %&gt;&lt;/p&gt;
            &lt;% } %&gt;
            ..
                </code></pre>
            </section>

            <section>
                <h3>once more, let us visit</h3>
                <h2>http://localhost:3000<b>/visits</b></h2>
                (keep refreshing, you'll see it)
            </section>

            <section>
                <h2>Socket.IO</h2>
                <h3>The final frontier</h3>
                (cue music)
            </section>

            <section>
                <h2>Firstly, what is Socket.IO?</h2>
                <h3>A Node JS module which provides bi-directional socket communication between client and server</h3>
            </section>

            <section>
                <h2>What makes it different from regular web traffic over port 80?</h2>
                <h3>Socket.IO establishes a <b style='color:00c0c0;'>persistent</b> open socket over which <b style='color:00c0c0;'>both server and client</b> can freely initiate communicate with each other</h3>
            </section>

            <section>
                <h2>What does Socket.IO have to do with Express?</h2>
                <h3>Socket.IO is its own thing, and neither Socket.IO nor Express require each other. But Socket.IO integrates with Express so easily that we just had to show it.</h3>
            </section>

            <section>
                <h2>Let's try it</h2>
                <h3>First, set up your dependency</h3>
                <pre><code data-trim>
                    ...
                        "debug": "~0.7.4",
                        "ejs": "~0.8.5",
                        "mongoose": "3.8.12",
                        "socket.io": "1.0.3"
                      }
                    }
                </code></pre>
                <h3>And install</h3>
                <pre><code data-trim>
                    $ npm install
                </code></pre>
            </section>

            <section>
                <h3>Socket.IO runs as its own server, alongside our Express app</h3>
                <pre><code data-trim>
                    var server = require('http').createServer(app);
                    var io = require('socket.io').listen(server);
                    server.listen(3001);
                </code></pre>
                (put this in app.js)
            </section>

            <section>
                <h3>We define "endpoints", or "namespaces" for the server, much like routes.</h3>
                <pre><code data-trim>
            // -- '/chat' is the namespace identifier
            // -- the callback function is the middleware we define
            // -- for the namespace identifier
            var chat = io.of('/chat').on('connection', function(socket){
                socket.on('chat', function(data){
                    data.color = 'green';
                    socket.emit('chat', data);
                    data.color = 'red';
                    socket.broadcast.emit('chat', data);
                });
            });
                </code></pre>
                (also put this in app.js)
            </section>

            <section>
                <h3>This is just an HTML form, which will help us interact with the server from the client</h3>
                <pre><code data-trim>
        &lt;div id="chatlog" style="height: 200px;overflow-y:scroll;"&gt;&lt;/div&gt;
        &lt;textarea id="chatwindow" cols="30" rows="10"&gt;&lt;/textarea&gt;
        &lt;input id="send_chat" type="submit" value="Send" /&gt;
                </code></pre>
                (this goes in our visits.ejs view)
            </section>

            <section>
                <h3>Here is our client-side javascript, which connects to, reacts to, and sends messages to the server</h3>
                <pre><code data-trim>
        &lt;script src="http://localhost:3001/socket.io/socket.io.js"&gt;&lt;/script&gt;
        &lt;script src="//code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt;

        &lt;script type="text/javascript"&gt;

            var chat_socket = io.connect('http://localhost:3001/chat');

            chat_socket.on('chat', function(data){
                $("#chatlog")
                    .append(
                        $("&lt;p style='color:" + data.color + ";'&gt;&lt;/p&gt;")
                            .text(data.isay)
                    );
            });

            $(document).on('click', "#send_chat", function(e){
                chat_socket.emit('chat', {isay: $("#chatwindow").val()});
                $("#chatwindow").val("");
            });

        &lt;/script&gt;
                </code></pre>
            </section>

            <!-- Act 3: Meteor.js and Reactive Apps -->
            <section>
                <h1>Act 3 (Denouement)</h1>
                <h2>Meteor</h2>
            </section>

            <section>
                <h1>Meteor</h1>
                <h3>A web app framework for real-time, reactive apps</h3>
                <h3>* powered by Node.js</h3>
            </section>
            <section>
                <h1>Real-time</h1>
                <h3>Server pushes data to all clients, immediately</h3>
            </section>
            <section>
                <h1>Reactive</h1>
                <h3>Changes on any client are immediately pushed to all other clients</h3>
            </section>
            <section>
                <h1>Slick, huh?</h1>
            </section>
            <section>
                <h2>Meteor is designed for single page apps</h2><br>
                <h4>So, no routing or multiple views out of the box</h4>
                (Though you can add them with packages)
            </section>
            <section>
                <h2>Let's check it out</h2>
                <h3>Install Meteor, and create a new dir</h3>
                <pre><code data-trim>
                $ npm install meteor -g
                $ mkdir node-act3
                $ cd node-act3
                </code></pre>
            </section>
            <section>
                <h2>Meteor has a generator, too!</h2>
                <pre><code data-trim>
                $ meteor create mapit
                $ cd mapit
                $ meteor
                </code></pre>
                <h4>Run "meteor --help" if you want to see behind the curtain</h4>

                <h3>and visit</h3>
                <h2>http://localhost:3000</h2>
            </section>
            <section>
                <h2>You'll notice that meteor claims it has started MongoDB</h2>
                <br>
                <h4>...even if you don't have MongoDB installed...</h4>
            </section>
            <section>
                <h1>That's because </h1><h1>Meteor is a liar!</h1>
            </section>
            <section>
                <h2>Just kidding!</h2>
                <h3>It's really because meteor has installed its own</h3><h3> embedded instance of Mongodb</h3>
                <br>
                <h4>You can access it anytime using:</h4>
                <pre><code data-trim>
                $ meteor mongo
                </code></pre>
            </section>
            <section>
                <h2>Let's check out the generated code</h2>
            </section>
            <section>
                <h2>Fibers</h2>
                <h3>Meteor uses a node.js library called <em>fibers</em>,</h3>
                <h3>which allows sequential execution of async functions, without callbacks</h3>
            </section>
            <section>
                <h2>We don't have time to go into how fibers works, but it's pretty cool</h2>
                <br>
                <h4>If you want to learn more: </h4>
                http://howtonode.org/generators-vs-fibers
                http://meteorhacks.com/fibers-eventloop-and-meteor.html
            </section>
            <section>
                <h2>This means meteor apps are straightforward to program</h2>
                <br>
                <h3>At the cost of some "framework magic"</h3>
            </section>
            <section>
                <h2>Meteor uses 3 default files:</h2>
                <ul>
                    <li>mapit.js -- client javascript and server code-behind</li>
                    <li>mapit.css -- styles</li>
                    <li>mapit.html -- client template/view</li>
                </ul>
            </section>
            <section>
                <h2>You'll see two sections in the mapit.js file:</h2>
                <pre><code data-trim>
                    if (Meteor.isClient) {
                        ...
                    }
                    if (Meteor.isServer) {
                        ...
                    }
                </code></pre>
            </section>
            <section>
                <h3>Any code outside these sections is <em>shared</em> between client and server</h3>
                <br>
                <h3>That's the beauty of an all-JavaScript app</h3>
            </section>
            <section>
                <h2>Collections</h2>
                <h4>Meteor stores data as javascipt objects in MongoDB collections</h4>
                <img src="./images/mongo_collections.png" width="80%"></img>
            </section>
            <section>
                <h2>But forget about HTTP POSTS or AJAX</h2>
                <br>
                <h3>With meteor you don't need them. Meteor handles all data synchronization between client and server</h3>
                <br>
                <h3>Collections are accessed as reactive streams of data</h3>
            </section>
            <section>
                <h1>Check this out</h1>
                <br>
                <h2>mapit.js:</h2>
                <pre><code data-trim>
                    Messages = new Meteor.collection('messages');
                    if (Meteor.isClient) {

                    }
                    if (Meteor.isServer) {
                        Meteor.startup(function () {
                            Messages.insert({'text': 'First message'});
                            Messages.insert({'text': 'Here\'s another'});
                        }

                        Meteor.publish("markers", function () {
                            return Markers.find();
                        });
                    }
                </code></pre>
            </section>
            <section>

            </section>
            <section>

            </section>
            <section>

            </section>
            <section>

            </section>

        </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
        // Required, even if empty.
        Reveal.initialize({
          transition: 'default'
        });
    </script>
</body>
</html>
